<?xml version="1.0" encoding="iso-8859-1"?>
<!DOCTYPE muclient>
<muclient>
<plugin
   name="Utility_ScrollSorter"
   author="Mendaloth/Kelaire"
   id="20324f91b0722c698a10f0a6"
   language="Lua"
   purpose="Will sort items with timers, which are in your inventory, by expiration."
   date_written="2011-12-30 22:45:00"
   requires="4.70"
   version="1.2"
   >
<description trim="y">
Type 'expiresort' to sort items with timers, which are in your inventory (not in a bag), by expiration.
</description>
</plugin>

<!--  Triggers  -->

<triggers>

<trigger
   enabled="n"
   match="{invdata}"
   name="start_inv"
   omit_from_output="y"
   sequence="100"
   send_to="14"
>
<send>
   expiring_inventory = {}
   EnableTrigger("invdata", true)
   EnableTrigger("end_inv", true)
</send>
</trigger>

<trigger
   enabled="n"
   match="{/invdata}"
   name="end_inv"
   omit_from_output="y"
   sequence="100"
   send_to="14"
>
<send>
   ReorderExpiringItems()
   EnableTrigger("invdata", false)
   EnableTrigger("end_inv", false)
</send>
</trigger>

<trigger
   enabled="n"
   match="^(\d+),(\w*),(.+),(\d+),(\d+),([01]),(-?\d+),(-?\d+)"
   name="invdata"
   omit_from_output="y"
   regexp="y"
   sequence="100"
   send_to="14"
   script="parseInvdata"
>
</trigger>
</triggers>

<aliases>

<alias
   match="^expiresort$"
   regexp="y"
   enabled="y"
   sequence="100"
   ignore_case="y"
   send_to="12"
>
<send>
   EnableTrigger("start_inv", true)
   SendNoEcho("invdata")
</send>
</alias>

</aliases>

<script>
<![CDATA[

expiring_inventory = {}

-- Use a batch to not spam/disconnect
-- Added function to send 25 commands every 5 seconds. Got rid of limits this way, without overspamming MUD
local give_idx = 1                -- current position in expiring_inventory
local batch_size = 25             -- how many 'give' commands per batch
local batch_delay_sec = 5.0       -- delay between batches
local reorder_total = 0           -- total items for this run
local batching_active = false     -- guard to prevent concurrent runs

function parseInvdata(name, line, wildcards, styles)
    local item_timer = wildcards[8] -- field 8 is timer
    if (item_timer ~= "-1") then -- -1 is no timer
        table.insert(expiring_inventory, {timer = tonumber(item_timer), objectid = wildcards[1]})
    end
end

-- Non-blocking batch sender
function ProcessGives()
    if not batching_active then
        return -- safety: nothing to do
    end

    local sent = 0
    while give_idx <= #expiring_inventory and sent < batch_size do
        local v = expiring_inventory[give_idx]
        -- send quietly
        SendNoEcho(("give %s self"):format(v.objectid))
        give_idx = give_idx + 1
        sent = sent + 1
    end

    if give_idx <= #expiring_inventory then
        -- schedule next batch
        DoAfterSpecial(batch_delay_sec, "ProcessGives()", sendto.script)
    else
        -- finished
        batching_active = false
        Note(("Reordering done.  You reordered %d items"):format(reorder_total))
        -- reset state for next run
        give_idx = 1
        reorder_total = 0
    end
end

function ReorderExpiringItems()
    require "tprint"
    table.sort(expiring_inventory, function(a,b) return a.timer < b.timer end)

    if batching_active then
        Note("A previous expiresort batch is still running. Please wait a moment and try again.")
        return
    end

    -- initialize batch run
    reorder_total = #expiring_inventory
    if reorder_total == 0 then
        Note("No expiring items found.")
        return
    end

    batching_active = true
    give_idx = 1
    -- kick off first batch immediately
    ProcessGives()
end

]]>
</script>
</muclient>


