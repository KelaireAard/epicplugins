<?xml version="1.0" encoding="iso-8859-1"?>
<!DOCTYPE muclient>
<!-- Saved on Friday, December 04, 2020, 9:13 AM -->
<!-- MuClient version 5.07-pre -->

<!-- Plugin "Tallimos_AutoInviter" generated by Plugin Wizard -->

<muclient>
<plugin
   name="Utility_AutoInviter"
   author="Tallimos/Kelaire"
   id="2dae6923b0384dba4ddff81f"
   language="Lua"
   purpose="Group auto inviter with Blacklist and Power User options"
   save_state="y"
   date_written="2020-12-04 09:12:45"
   requires="4.37"
   version="1.65"
   >

</plugin>

<!--  Get our standard constants -->

<include name="constants.lua"/>
-- 
<!--  Triggers  -->
<triggers>
	<trigger
		group="PowerUsers"
		match="^(.*?) was not found\.$"
		name="PowerUsersNotFound"
		script="NotFound"
		sequence="90"
		regexp="y"
		ignore_case="y"
		>
	</trigger>
	<trigger
		group="PowerUsers"
		match="^(\w+) has already been invited into this group\.$"
		name="PowerUsersAlreadyInvited"
		script="AlreadyInvited"
		sequence="90"
		regexp="y"
		ignore_case="y"
		>
	</trigger>
	<trigger
		group="PowerUsers"
		match="^Your group is already (\w+)\.$"
		name="PowerUsersFlag"
		script="AlreadyFlag"
		sequence="90"
		regexp="y"
		ignore_case="y"
		>
	</trigger>
	<trigger
		group="PowerUsers"
		match="^Group name cannot be more than 25 characters\.$"
		name="PowerUsersGroupName"
		script="GroupNameLong"
		sequence="90"
		regexp="y"
		ignore_case="y"
		>
	</trigger>
	<trigger
		group="PowerUsers"
		match="^\(Group\)\s(\w+)\:\s'\.rename (.*?)'$"
		name="PowerUsersRename"
		script="PowerUsersRename"
		sequence="90"
		regexp="y"
		ignore_case="y"
		>
	</trigger>
	<trigger
		group="PowerUsers"
		match="^\(Group\)\s(\w+)\:\s\'\.(.*?)\'$"
		name="PowerUsers"
		script="PowerUsers"
		sequence="100"
		regexp="y"
		ignore_case="y"
		>
	</trigger>

	<trigger
		group="AutoInviter"
		match="^(\w+) has declined your invitation by joining a different group\.$"
		name="DeclinedAnotherGroup"
		script="DeclinedAnotherGroup"
		sequence="100"
		regexp="y"
		ignore_case="y"
		>
	</trigger>
	<trigger
		group="AutoInviter2"
		match="^(\w+) is a member of another group\.$"
		name="AnotherGroup"
		script="AnotherGroup"
		sequence="100"
		regexp="y"
		ignore_case="y"
		>
	</trigger>
	<trigger
		group="AutoInviter"
		match="^(\w+) tells you \'(.*?)\'$"
		name="Tells"
		script="Invite"
		sequence="100"
		regexp="y"
		ignore_case="y"
		>
	</trigger>
	<trigger
		group="AutoInviter"
		match="^\(Group\) (\w+) has joined the group\.$"
		name="Joined"
		script="Joined"
		sequence="100"
		regexp="y"
		ignore_case="y"
		>
	</trigger>
	<trigger
		group="AutoInviter"
		match="^\(Group\) The group has been disbanded by (.*?)\.$"
		name="Disbanded"
		script="Disbanded"
		sequence="100"
		regexp="y"
		ignore_case="y"
		>
	</trigger>
</triggers>

<!--  Aliases  -->

<aliases>
	<alias
		script="CommandMenu"
		match="^(?:tai|tautoinvite|tautoinviter) (.*?)$"
		enabled="y"
		ignore_case="y"
		regexp="y"
		sequence="100"
		>
	</alias>
</aliases>

<script>
<![CDATA[
require "tprint"
require "mw_theme_base"
require "serialize"
require "commas"
require "gmcphelper"
require "copytable"
require "aardmapper"
require "aard_lua_extras"
require "wait"
require "async"

local remain_colour   = "lime"
local user_colour   = "yellow"
local reason_colour     = "red"
local msg_colour      = "lightslategrey"
local err_colour      = "firebrick"
local help_colour     = "lightslategrey"
local qty_colour      = "cyan"
local optional_colour = "lightcoral"
local command_colour  = "white"
local cmd_required    = "royalblue"
local help_command_colour  = "red"

local noteline = "=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-="

---------------------------------------------
--------------- MENU FUNCTION ---------------
---------------------------------------------
function CommandMenu(name, line, wc)
	commandline = trim(string.lower(wc[1]))
	wordtable = utils.split (commandline, " ")

	cmd = wordtable[1]
	
	if cmd == "enable" then
		EnableInviter()
	elseif cmd == "disable" then
		DisableInviter()
	elseif cmd == "check" then
		user = wordtable[2]
		if user ~= nil then 
			if InGroup() == "no" then
				ColourNote(msg_colour, "", "You are not a member of a group.")
				return
			end

			if IsUserInGroup(user) == "yes" then
				user = string.gsub (user, "^.", string.upper)
				SendNoEcho ("gt @C" .. user .. " @Dis in the group.")
			elseif IsUserInGroup(user) == "no" then
				user = string.gsub (user, "^.", string.upper)
				SendNoEcho ("gt @C" .. user .. " @Dis not in the group.")
			end
		else
			ColourNote(msg_colour, "", "Command usage: ", help_command_colour, "", "tai check <player name>")
		end
	elseif cmd == "blacklist" or cmd == "bl" then
		if wordtable[2] == nil then
			ListBlacklist()
		else
			attrib = wordtable[2]
			
			if attrib == "enable" then
				EnableBlacklist()
			elseif attrib == "disable" then
				DisableBlacklist()
			elseif attrib == "add" then
				reason = nil
				
				user = wordtable[3]
				wordcount = 0

				for i,v in ipairs(wordtable) do
					wordcount = wordcount + 1
				end
				
				for x = 4, wordcount, 1 do
					if reason == nil then
						reason = wordtable[x]
					else
						reason = reason .. " " .. wordtable[x]
					end
				end
				
				if reason == nil then reason = "N/A" end
				
				AddBlacklist(user, reason)
			elseif attrib == "remove" then
				user = wordtable[3]
				RemoveBlacklist(user)
			else
				ColourNote(msg_colour, "", "Invalid command. Please see ", help_command_colour, "", "tai help", msg_colour, "", " for more information.")
			end
		end
	elseif cmd == "keywords" then
		ListKeywords()
	elseif cmd == "keyword" then
		attrib = wordtable[2]
		
		wordcount = 0
		keyword = nil
		
		for i,v in ipairs(wordtable) do
			wordcount = wordcount + 1
		end
		
		for x = 3, wordcount, 1 do
			if keyword == nil then
				keyword = wordtable[x]
			else
				keyword = keyword .. " " .. wordtable[x]
			end
		end

		if attrib == "add" then
			AddKeyword(keyword)
		elseif attrib == "remove" then
			RemoveKeyword(keyword)
		else
			ColourNote(msg_colour, "", "Invalid command. Please see ", help_command_colour, "", "tai help", msg_colour, "", " for more information.")
		end
	elseif cmd == "pending" then
		ListPending()
	elseif cmd == "lock" then
		LockGroup()
	elseif cmd == "unlock" then
		UnlockGroup()
	elseif cmd == "autolock" then
		locknum = tonumber(wordtable[2])
		
		if locknum == nil then
			ColourNote(msg_colour, "", "Auto lock needs a number to set.")
		else
			AutolockGroup(locknum)
		end
	elseif cmd == "pusers" then
		ListPowerUsers()
	elseif cmd == "puser" then
		attrib = wordtable[2]
	
		if attrib == "add" then
			user = wordtable[3]
			AddPowerUser(user)
		elseif attrib == "remove" then
			user = wordtable[3]
			RemovePowerUser(user)
		elseif attrib == "enable" then
			EnablePowerUsers()
		elseif attrib == "disable" then
			DisablePowerUsers()
		else
			ColourNote(msg_colour, "", "Invalid command. Please see ", help_command_colour, "", "tai help", msg_colour, "", " for more information.")
		end
	elseif cmd == "vi" then		
		if InviterTable["VI"] == "YES" then
			InviterTable["VI"] = "NO"
			ColourNote(msg_colour, "", "VI friendy option disabled.")
		elseif InviterTable["VI"] == "NO" then
			InviterTable["VI"] = "YES"
			ColourNote(msg_colour, "", "VI friendy option enabled.")			
		end
	elseif cmd == "bonk" then		
		if InviterTable["Bonk"] == "YES" then
			InviterTable["Bonk"] = "NO"
			ColourNote(msg_colour, "", "Bonking has been disabled.")
		elseif InviterTable["Bonk"] == "NO" then
			InviterTable["Bonk"] = "YES"
			ColourNote(msg_colour, "", "Bonking has been enabled.")			
		end
	elseif cmd == "update" then
		-- dbot.version.update.release(drlDbotUpdateInstall, endTag)
		tai_update()
		InviterTable["Updating"] = "YES"
	elseif cmd == "changelog" then
		dbot.print("@DFull changelog:")
		dbot.version.changelog.get(0, endTag) -- show changelog from version 0 to the latest
	elseif cmd == "checkversion" then
		dbot.version.update.release(drlDbotUpdateCheck, endTag)
	elseif cmd == "help" then
		AutoInviterHelp()
	else
		ColourNote(msg_colour, "", "Invalid command. Please see ", qty_colour, "", "tai help", msg_colour, "", " for more information.")
	end
	
	SaveState()
end -- CommandMenu

---------------------------------------------
-------------- CHECK FUNCTIONS --------------
---------------------------------------------
function InGroup()
	gmcpgroup = gmcp("group")

	if gmcpgroup.groupname == nil or gmcpgroup.groupname == "" then
		ingroup = "no"
	else
		ingroup = "yes"
	end
	
	return ingroup
end -- InGroup

function IsUserInGroup(user)

	gmcpgroup = gmcp("group")
	
	ismember = "no"

	for i, v in ipairs(gmcpgroup.members) do
		grmem = string.lower(gmcpgroup.members[i].name)
		if grmem == user then
			ismember = "yes"
		end
	end

	return ismember
end -- IsUserInGroup

function GetCharName()
	gmcpbase = gmcp("char.base")
	charname = string.lower(gmcpbase.name)
end -- GetCharName

function GroupCount()
	gmcpgroup = gmcp("group")
	count = tonumber(gmcpgroup.count)
	
	return count
end -- GroupCount

function GroupLeader()
	gmcpgroup = gmcp("group")
	leadername = string.lower(gmcpgroup.leader)
	
	return leadername
end -- GroupLeader

----------------------------------------------
--------------- MAIN FUNCTIONS ---------------
----------------------------------------------
function EnableInviter()
	if InGroup() == "no" then
	 	ColourNote(msg_colour, "", "You are not a member of a group.")
	 	return
	end
	
	GetCharName()

	InviterTable["Pending"] = {}
	pindex = 0
	
	world.EnableGroup ("AutoInviter", 1)

	if InviterTable["BlacklistEnabled"] == true then
		if InviterTable["PowerUserEnabled"] == true then
			ColourNote(msg_colour, "", "Auto Inviter is now ENABLED. Blacklist is ON. Power User commands ENABLED.")
			world.EnableGroup ("PowerUsers", 1)
		elseif InviterTable["PowerUserEnabled"] == false then
			ColourNote(msg_colour, "", "Auto Inviter is now ENABLED. Blacklist is ON. Power User commands DISABLED.")
			world.EnableGroup ("PowerUsers", 0)			
		end
	else
		if InviterTable["PowerUserEnabled"] == true then
			ColourNote(msg_colour, "", "Auto Inviter is now ENABLED. Blacklist is OFF. Power User commands ENABLED.")
			world.EnableGroup ("PowerUsers", 1)
		elseif InviterTable["PowerUserEnabled"] == false then
			ColourNote(msg_colour, "", "Auto Inviter is now ENABLED. Blacklist is OFF. Power User commands DISABLED.")
			world.EnableGroup ("PowerUsers", 0)
		end
	end
end -- EnableInviter

function DisableInviter()
	ColourNote(msg_colour, "", "Auto Inviter is now DISABLED.")
	
	world.EnableGroup ("AutoInviter", 0)
end -- DisableInviter

function Invite(name, line, wc)
	user = string.lower(wc[1])
	keyword = string.lower(wc[2])
	user2 = string.gsub (user, "^.", string.upper)
	
	EnableTrigger("AnotherGroup", true)
	
	if InviterTable["BlacklistEnabled"] == true then
		if CheckBlackList(user) == "yes" then
			reason = InviterTable["Blacklist"][user]["Reason"]
			ColourNote(qty_colour, "", user, msg_colour, "", " has been blacklisted. Reason: ", qty_colour, "", reason)
			return
		end
	end
	
	keywordcheck = "no"
	
	for i,v in pairs(InviterTable["Keywords"]) do
		validkeyword = string.lower(i)
		
		if validkeyword == keyword then
			keywordcheck = "yes"
		end
	end
	
	if keywordcheck == "no" then
		return
	end

	if InGroup() == "no" then
	
	 	SendNoEcho ("tell " .. user .. " @DSorry @C" .. user2 .. " @Dbut I am not in a group at this time.@w")
	 	return
	end
	
	if IsUserInGroup(user) == "yes" then
		SendNoEcho ("tell " .. user .. " @C" .. user2 .. " @Dyou are already in the group.@w")
	else
		if CheckPending(user) == "yes" then
			SendNoEcho ("tell " .. user .. " @C" .. user2 .. " @Dyou have already been invited! Type '@Cgroup accept " .. charname .. "@D'@w")
		else
			GetCharName()
			
			if GroupLeader() ~= charname then
				local leader = GroupLeader()
				leader = string.gsub (leader, "^.", string.upper)
				
				SendNoEcho ("tell " .. user .. " @DSorry @C" .. user2 .. " @Dbut I am not the leader at this time. @C" .. leader .. " @Dis the current leader of the group.@w")
				return
			end
		
			SendNoEcho ("group invite " .. user)
			
			pindex = pindex + 1
			
			InviterTable["Pending"][user] = {}
			InviterTable["Pending"][user]["Invite Number"] = pindex
			InviterTable["Pending"][user]["Invite Time"] = os.time()
			
			ColourNote(msg_colour, "", "Invite #", qty_colour, "", pindex, msg_colour, "", " sent to ", qty_colour, "", user)
		end
	end
end -- Invite

function AnotherGroup(name, line, wc)
	user = string.lower(wc[1])
	
	if InviterTable["Bonk"] == "YES" then
		SendNoEcho("bonk " .. user)
	end
	
	SendNoEcho("tell " .. user .. " @DLeave your current group and try again!@w")
		
	if CheckPending(user) == "yes" then
		RemovePending(user)
	end
	
	EnableTrigger("AnotherGroup", false)
end -- AnotherGroup

function DeclinedAnotherGroup(name, line, wc)
	user = string.lower(wc[1])
	
	if CheckPending(user) == "yes" then
		RemovePending(user)
	end
end -- AnotherGroup

function Joined(name, line, wc)
	user = string.lower(wc[1])
	
	if CheckPending(user) == "yes" then
		RemovePending(user)
	end
end -- AnotherGroup

function Disbanded(name, line, wc)	
	GetCharName()
	local name = string.lower(wc[1])
	
	if name == charname then
		DisableInviter()
	end
end -- Disbanded

function LockGroup()
	EnableTrigger ("Tells", false)
	ColourNote(msg_colour, "", "Group has been ", qty_colour, "", "LOCKED", msg_colour, "", " and you will no longer accept invite requests")
	
	if next (InviterTable["Pending"]) ~= nil then
		for i,v in pairs (InviterTable["Pending"]) do
			SendNoEcho("group cancel " .. i)
		end
		
		InviterTable["Pending"] = {}
	end
		
	if InviterTable["Autolock"] == true then
		InviterTable["Autolock"] = false
		
		Note("")
		ColourNote(msg_colour, "", "Autolock has been ", qty_colour, "", "deactivated", msg_colour, "", ". Reason: ", qty_colour, "", "Group count has reached " .. locknum)
	end
end -- LockGroup

function UnlockGroup()
	EnableTrigger ("Tells", true)
	ColourNote(msg_colour, "", "Group has been ", qty_colour, "", "UNLOCKED", msg_colour, "", " and you will now accept invite requests")
end -- UnlockGroup

function AutolockGroup(locknum)
	InviterTable["Autolock"] = true
	
	ColourNote(msg_colour, "", "Group has been set to ", qty_colour, "", "AUTOLOCKED", msg_colour, "", " and you will stop accepting invite requests after ", qty_colour, "", locknum, msg_colour, "", " group members.")
end -- AutolockGroup

---------------------------------------------
------------- PENDING FUNCTIONS -------------
---------------------------------------------
function CheckPending(user)
	pcheck = "no"
		
	if InviterTable["Pending"] == nil or InviterTable["Pending"] == "" then	
		return pcheck
	end
	
	for i,v in pairs(InviterTable["Pending"]) do
		cuser = i

		if cuser == user then
			pcheck = "yes"
		end
	end

	return pcheck
end -- CheckPending

function RemovePending(user)	
	
	for i,v in pairs(InviterTable["Pending"]) do
		if i == user then
			InviterTable["Pending"][i] = nil
		end
	end

	if InviterTable["Autolock"] == true then
		if GroupCount() >= locknum then LockGroup() end
	end
end -- RemovePending

function ListPending()
	title = "Pending Invite List"

	local title2 = "+--------------+----------+--------------------------------------------+"
	
	local leng = tonumber(string.len(title))
	local leng2 = tonumber(string.len(title2))
	
	spacing = TitleSpacing(title, title2)
	
	ColourNote(help_colour, "", spacing, help_command_colour, "", title)
	Note("")

	if InviterTable["VI"] == "NO" then
		ColourNote(msg_colour, "", title2)
		ColourNote(msg_colour, "", "| Name         | Invite # | Time Pending                               |")
		ColourNote(msg_colour, "", title2)
	end
	
	for i,v in pairs(InviterTable["Pending"]) do
		username = string.gsub (i, "^.", string.upper)
		invitenum = InviterTable["Pending"][i]["Invite Number"]
		
		local timenow = os.time()
		local timenow2 = InviterTable["Pending"][i]["Invite Time"]
		
		local timediff2 = {}

		timeDiff(timenow,timenow2,timediff2)

		local timeonlist = remainingtime_note(timediff2)
	
		if username == nil then namespace = 12 else namespace = MakeSpace(username, 12) end
		
		if invitenum == nil then invitespace = 8 else invitespace = MakeSpace(invitenum, 8) end
		
		if timeonlist == nil then onlistspace = 42 else onlistspace = MakeSpace(timeonlist, 42) end

		if InviterTable["VI"] == "NO" then
			ColourNote(msg_colour, "", "| ", user_colour, "", username .. namespace, msg_colour, "", " | ", reason_colour, "", invitenum .. invitespace, msg_colour, "", " | ", remain_colour, "", timeonlist .. onlistspace, msg_colour, "", " |")
		elseif InviterTable["VI"] == "YES" then			
			ColourNote(msg_colour, "", "User: ", user_colour, "", username .. namespace, msg_colour, "", " Invite Number: ", reason_colour, "", invitenum .. invitespace, msg_colour, "", " Time on Pending List: ", remain_colour, "", timeonlist .. onlistspace)
		end
	end

	if InviterTable["VI"] == "NO" then
		ColourNote(msg_colour, "", title2)
	end
end -- ListPending

---------------------------------------------
------------ BLACKLIST FUNCTIONS ------------
---------------------------------------------
function AddBlacklist(user, reason)	
	if CheckBlackList(user) == "yes" then
		ColourNote(qty_colour, "", user, msg_colour, "", " has already been added to the blacklist.")
		
		return
	end
		
	ColourNote(qty_colour, "", user, msg_colour, "", " has been added to the blacklist. Reason: ", qty_colour, "", reason)

	InviterTable["Blacklist"][user] = {}
	InviterTable["Blacklist"][user]["Reason"] = reason
	InviterTable["Blacklist"][user]["Since"] = os.time()
	SaveState()
end -- AddBlacklist

function RemoveBlacklist(user)
	if CheckBlackList(user) == "no" then
		ColourNote(qty_colour, "", user, msg_colour, "", " was not found on the blacklist.")
		return
	end
	
	ColourNote(qty_colour, "", user, msg_colour, "", " has been removed from the blacklist.")

	InviterTable["Blacklist"][user] = nil
	SaveState()
end -- RemoveBlacklist

function CheckBlackList(user)
	bcheck = "no"
	
	for i,v in pairs(InviterTable["Blacklist"]) do
		if user == i then
			bcheck = "yes"
		end
	end
	
	return bcheck
end -- CheckBlackList

function ListBlacklist()
	title = "Players on the Blacklist"
	
	local title2 = "+--------------+--------------------------------+--------------------------------------------+"
	
	local leng = tonumber(string.len(title))
	local leng2 = tonumber(string.len(title2))
	
	spacing = TitleSpacing(title, title2)
	
	ColourNote(help_colour, "", spacing, help_command_colour, "", title)
	Note("")

	if InviterTable["VI"] == "NO" then
		ColourNote(msg_colour, "", title2)
		ColourNote(msg_colour, "", "| Name         | Reason                         | Time on List                               |")
		ColourNote(msg_colour, "", title2)
	end
	
	for i,v in pairs(InviterTable["Blacklist"]) do
		username = string.gsub (i, "^.", string.upper)
		reason = InviterTable["Blacklist"][i]["Reason"]
		
		local timenow = os.time()
		local timenow2 = InviterTable["Blacklist"][i]["Since"]
		
		local timediff2 = {}

		timeDiff(timenow,timenow2,timediff2)

		local timeonlist = remainingtime_note(timediff2)
		
		if username == nil then namespace = 12 else namespace = MakeSpace(username, 12) end
		
		if reason == nil then reasonspace = 30 else reasonspace = MakeSpace(reason, 30) end
		
		if timeonlist == nil then onlistspace = 42 else onlistspace = MakeSpace(timeonlist, 42) end

		if InviterTable["VI"] == "NO" then
			ColourNote(msg_colour, "", "| ", user_colour, "", username .. namespace, msg_colour, "", " | ", reason_colour, "", reason .. reasonspace, msg_colour, "", " | ", remain_colour, "", onlistspace .. timeonlist,  msg_colour, "", " |")
		elseif InviterTable["VI"] == "YES" then
			ColourNote(msg_colour, "", "User: ", user_colour, "", username .. namespace, msg_colour, "", " Reason: ", reason_colour, "", reason, msg_colour, "", " Time on Blacklist: ", remain_colour, "", timeonlist)
		end
	end

	if InviterTable["VI"] == "NO" then
		ColourNote(msg_colour, "", title2)
	end
end -- ListBlacklist

function EnableBlacklist()
	ColourNote(msg_colour, "", "Blacklist Enabled.")
	Note("")
	ColourNote(msg_colour, "", "Any requests from players on the blacklist will be ignored.")
	
	InviterTable["BlacklistEnabled"] = true
	SaveState()
end -- EnableBlacklist

function DisableBlacklist()
	ColourNote(msg_colour, "", "Blacklist Disabled.")
	Note("")
	ColourNote(msg_colour, "", "No requests will be ignored.")

	InviterTable["BlacklistEnabled"] = false
	SaveState()
end	 -- DisableBlacklist

---------------------------------------------
------------- KEYWORD FUNCTIONS -------------
---------------------------------------------
function CheckKeyword(keyword)
	kcheck = "no"
	
	for i,v in pairs(InviterTable["Keywords"]) do
		if keyword == i then
			kcheck = "yes"
		end
	end
end -- CheckKeyword

function AddKeyword(keyword)	
	if CheckKeyword(keyword) == "yes" then
		ColourNote(qty_colour, "", keyword, msg_colour, "", " has already been added to the keyword list..")
		
		return
	end
		
	ColourNote(qty_colour, "", keyword, msg_colour, "", " has been added to the keyword list.")

	InviterTable["Keywords"][keyword] = keyword
	SaveState()
end -- AddKeyword

function RemoveKeyword(keyword)
	if CheckKeyword(keyword) == "no" then
		ColourNote(qty_colour, "", keyword, msg_colour, "", " was not added to the keyword list.")
		return
	end
	
	ColourNote(qty_colour, "", keyword, msg_colour, "", " has been removed from the keyword list.")

	InviterTable["Keywords"][keyword] = nil
	SaveState()
end -- RemoveKeyword

function ListKeywords()
	title  = "Keyword List"
	title2 = "------------"
		
	ColourNote(msg_colour, "", title)
	if InviterTable["VI"] == "NO" then
		ColourNote(msg_colour, "", title2)
	elseif InviterTable["VI"] == "YES" then
		Note("")
	end
	
	for i,v in pairs(InviterTable["Keywords"]) do
		ColourNote(qty_colour, "", i)
	end
end -- ListKeywords

----------------------------------------------
------------ POWER USER FUNCTIONS ------------
----------------------------------------------
function AddPowerUser(user)	
	if CheckPowerUser(user) == "yes" then
		ColourNote(qty_colour, "", user, msg_colour, "", " has already been added to the power users list.")
		
		return
	end
	
	username = string.gsub (user, "^.", string.upper)
	-- SendNoEcho("gt @C" .. username .. " @Dhas been added to the power users list.@w")
	
	ColourNote(qty_colour, "", username, msg_colour, "", " has been added to the power users list.")

	InviterTable["Power Users"][user] = {}
	InviterTable["Power Users"][user]["Since"] = os.time()
	SaveState()
end -- AddPowerUser

function RemovePowerUser(user)
	if CheckPowerUser(user) == "no" then
		ColourNote(qty_colour, "", user, msg_colour, "", " was not found on the power users list.")
		return
	end
	
	username = string.gsub (user, "^.", string.upper)
	-- SendNoEcho("gt @C" .. username .. " @Dhas been removed from the power users list.@w")
	
	ColourNote(qty_colour, "", username, msg_colour, "", " has been removed from the power users list.")
	
	InviterTable["Power Users"][user] = nil
	SaveState()
end -- RemovePowerUser

function CheckPowerUser(user)
	ucheck = "no"
	
	for i,v in pairs(InviterTable["Power Users"]) do
		if user == i then
			ucheck = "yes"
		end
	end
	
	return ucheck
end -- CheckPowerUser

function ListPowerUsers()
	title = "Power Users List"
	
	local title2 = "+--------------+--------------------------------------------+"
	
	local leng = tonumber(string.len(title))
	local leng2 = tonumber(string.len(title2))
	
	spacing = TitleSpacing(title, title2)
	
	ColourNote(help_colour, "", spacing, help_command_colour, "", title)
	Note("")

	if InviterTable["VI"] == "NO" then
		ColourNote(msg_colour, "", title2)
		ColourNote(msg_colour, "", "| Name         | Time on List                               |")
		ColourNote(msg_colour, "", title2)
	end
	
	for i,v in pairs(InviterTable["Power Users"]) do
		username = string.gsub (i, "^.", string.upper)
		
		local timenow = os.time()
		local timenow2 = InviterTable["Power Users"][i]["Since"]
		
		local timediff2 = {}

		timeDiff(timenow,timenow2,timediff2)

		local timeonlist = remainingtime_note(timediff2)
		
		if username == nil then namespace = 12 else namespace = MakeSpace(username, 12) end
		
		if timeonlist == nil then onlistspace = 42 else onlistspace = MakeSpace(timeonlist, 42) end
		
		if InviterTable["VI"] == "NO" then
			ColourNote(msg_colour, "", "| ", user_colour, "", username .. namespace, msg_colour, "", " | ", remain_colour, "", onlistspace .. timeonlist,  msg_colour, "", " |")
		elseif InviterTable["VI"] == "YES" then
			ColourNote(msg_colour, "", "User: ", user_colour, "", username .. namespace, msg_colour, "", " Time on Power List: ", remain_colour, "", timeonlist)
		end
	end

	if InviterTable["VI"] == "NO" then
		ColourNote(msg_colour, "", title2)
	end
end -- ListPowerUsers

function EnablePowerUsers()
	ColourNote(msg_colour, "", "Power User commands enabled.")
	Note("")
	
	EnableTrigger ("PowerUsers", true)
	InviterTable["PowerUserEnabled"] = true
	SaveState()
end -- EnablePowerUsers

function DisablePowerUsers()
	ColourNote(msg_colour, "", "Power User comamnds disabled.")
	Note("")
	
	EnableTrigger ("PowerUsers", false)
	InviterTable["PowerUserEnabled"] = false
	SaveState()
end	 -- DisablePowerUsers

function PowerUsers(name, line, wc)
	user = string.lower(wc[1])
	commandline = trim(string.lower(wc[2]))
	wordtable = utils.split (commandline, " ")

	if CheckPowerUser(user) == "no" then
		-- ColourNote(qty_colour, "", user, msg_colour, "", " is not a power user.")
		return
	end

	cmd = wordtable[1]
	
	if cmd == "invite" then
		if wordtable[2] ~= nil then
			player = string.lower(wordtable[2]) 
		else
			SendNoEcho ("gt @DPlease provide a player name to invite.@w")
			return
		end

		username = string.gsub (player, "^.", string.upper)
	
		if IsUserInGroup(player) == "no" then
			SendNoEcho ("gt @DSending invite to @C" .. username .. "@D.@w")
			SendNoEcho ("group invite " .. player)
		else
			SendNoEcho ("gt @C" .. username .. " @Dis already in the group@w.")
		end
	elseif cmd == "kick" then
		GetCharName()
		
		if wordtable[2] ~= nil then
			player = string.lower(wordtable[2]) 
		else
			SendNoEcho ("gt @DPlease provide a player name to kick.@w")
			return
		end

		if IsUserInGroup(player) == "yes" then
			if player ~= charname then
				SendNoEcho ("group kick " .. player)
			else
				SendNoEcho ("gt @DThat would just be silly.@w")
			end
		else
			player = string.gsub (player, "^.", string.upper)
			SendNoEcho ("gt @C" .. player .. "@D is not in the group.@w")
		end
	elseif cmd == "leader" then
		if wordtable[2] ~= nil then
			player = string.lower(wordtable[2]) 
		else
			SendNoEcho ("gt @DPlease provide a player name to leader.@w")
			return
		end

		if IsUserInGroup(player) == "yes" then
			GetCharName()
	
			if GroupLeader() == charname then
				if charname ~= player then
					SendNoEcho ("group leader " .. player)
				else
					SendNoEcho ("gt @DI am already group leader.")
				end
			else
				-- SendNoEcho ("gt @DI am not group leader.")
			end
		else
			player = string.gsub (player, "^.", string.upper)
			SendNoEcho ("gt @C" .. player .. "@D is not in the group.@w")
		end
	elseif cmd == "cancel" then
		if wordtable[2] ~= nil then
			player = wordtable[2]
		else
			SendNoEcho ("gt @DPlease provide a player name to cancel their invite.@w")
			return
		end

		SendNoEcho ("gt @DCanceling invite for @C" .. player .. "@D.@w")
		SendNoEcho ("group cancel " .. player)
	elseif cmd == "reset" then
		SendNoEcho ("group stats reset")		
	elseif cmd == "flag" then
		flag = wordtable[2]
		
		if flag == "public" or flag == "private" then
			SendNoEcho ("group flag " .. flag)
		else
			SendNoEcho ("gt @DInvalid flag.@w")
		end
	elseif cmd == "disband" then
		confirm = wordtable[2]

		if confirm == "confirm" then
			SendNoEcho ("group disband confirm")
		else
			SendNoEcho ("gt @DCommand usage: @C.disband confirm@w.")
		end
	elseif cmd == "help" then
		attrib = wordtable[2]
		PowerUserHelp(user, attrib)
	end
end -- PowerUsers

function PowerUsersRename(name, line, wc)
	user = string.lower(wc[1])
	title = wc[2]

	if CheckPowerUser(user) == "no" then
		return
	end

	SendNoEcho ("group rename " .. title)
end -- PowerUsersRename

function AlreadyInvited(name, line, wc)
	user = wc[1]
	SendNoEcho("gt @C" .. user .. " @Dhas already been invited.@w")
end

function AlreadyFlag(name, line, wc)
	flag = wc[1]
	SendNoEcho("gt @DGroup has already been set to @C" .. flag .. "@D.@w")
end

function NotFound(name, line, wc)
	user = wc[1]
	SendNoEcho("gt @C" .. user .. " @Dnot found.@w")
end

function GroupNameLong(name, line, wc)
	SendNoEcho("gt @DGroup name cannot be more then @C25 @Dcharacters.@w")
end

function PowerUserHelp(user, cmd)
	if cmd == nil or cmd == "" then
		user = string.gsub (user, "^.", string.upper)
		SendNoEcho ("gt @DHello @C" .. user .. "@D, available commands: @C.invite@D, @C.cancel@D, @C.kick@D, @C.leader@D, @C.rename@D, @C.reset@D, @C.flag@D, @Dand @C.disband@D. Please see @C.help <cmd> @Dfor more information, i.e. @C.help invite@D.@w")	
	elseif cmd == "invite" then
		SendNoEcho ("gt @R[PUSer Help] @C.invite <player> @D- send an invite to a specific player.@w")
	elseif cmd == "cancel" then
		SendNoEcho ("gt @R[PUSer Help] @C.cancel <player> @D- cancel invite to a specific player@w")
	elseif cmd == "kick" then
		SendNoEcho ("gt @R[PUSer Help] @C.kick <player> @D- kicks a specific player from the group@w")
	elseif cmd == "leader" then
		SendNoEcho ("gt @R[PUSer Help] @C.leader <player> @D- promotes a specific player as group leader@w")
	elseif cmd == "rename" then
		SendNoEcho ("gt @R[PUSer Help] @C.rename <title> @D- changes the groups's name, use @@@@ for colour codes@w")
	elseif cmd == "reset" then
		SendNoEcho ("gt @R[PUSer Help] @C.reset @D- resets the group stats, information found in group header@w")
	elseif cmd == "flag" then
		SendNoEcho ("gt @R[PUSer Help] @C.flag <public|private> @D- changes the group to either public or private@w")
	elseif cmd == "disband" then
		SendNoEcho ("gt @R[PUSer Help] @C.disband confirm @D- disbands the group@w")
	else
		user = string.gsub (user, "^.", string.upper)
		SendNoEcho ("gt @DSorry @C" .. user .. "@D, that is not a valid option.@w")
	end
end -- PowerUserHelp

-----------------------------------------------
-------------- UTILITY FUNCTIONS --------------
-----------------------------------------------
function TitleSpacing(title, title2)
	local leng = tonumber(string.len(title))
	local leng2 = tonumber(string.len(title2))
	
	local spacing = 0
	local lendif = 0
	
	if leng > leng2 then
	else
		lendif = leng2 - leng
		lendif = lendif * 0.5
	end

	spacing = string.rep(" ", lendif)
	
	return spacing
end -- TitleSpacing

function MakeSpace(title, maxleng)
	local leng = tonumber(string.len(title))
	local leng2 = tonumber(maxleng)
	
	local spacing = 0
	local lendif = 0
	
	if leng > leng2 then
	else
		lendif = leng2 - leng
	end

	spacing = string.rep(" ", lendif)
	return spacing
end -- MakeSpace

function remainingtime_note(time)
	remaining_time = ""

	if time["year"] ~= nil then
		if tonumber(time["year"]) == 1 then
			remaining_time = time["year"] .. " year  "
		elseif tonumber(time["year"]) ~= 0 then
			remaining_time = time["year"] .. " years "
		end
	end

	ttype = "month"
	remaining_time = GetTimeMessage(time, ttype, remaining_time)
	
	ttype = "day"
	remaining_time = GetTimeMessage(time, ttype, remaining_time)
	
	ttype = "hour"
	remaining_time = GetTimeMessage(time, ttype, remaining_time)

	ttype = "min"
	remaining_time = GetTimeMessage(time, ttype, remaining_time)

	ttype = "sec"
	remaining_time = GetTimeMessage(time, ttype, remaining_time)
	
    return(remaining_time)
end -- remainingtime_note

function GetTimeMessage(time, ttype, remaining_time)
	if remaining_time == nil then
		remaining_time = ""
	end

	if time[ttype] ~= nil then
		if tonumber(time[ttype]) == 1 then
			remaining_time = remaining_time .. time[ttype] .. " " .. ttype .. " "
		elseif tonumber(time[ttype]) ~= 0 then
			remaining_time = remaining_time .. time[ttype] .. " " .. ttype .. "s "
		end
	end
	
	return (remaining_time)
end -- GetTimeMessage

-- FUNCTION TO CALCULATION DIFFERENCE BETWEEN TWO TIMES
function timeDiff(t2,t1,script)
    local d1,d2,carry,diff = os.date('*t',t1),os.date('*t',t2),false,{}

	tprint(diff)
    local colMax = {60,60,24,os.date('*t',os.time{year=d1.year,month=d1.month+1,day=0}).day,12}
    d2.hour = d2.hour - (d2.isdst and 1 or 0) + (d1.isdst and 1 or 0) -- handle dst
    for i,v in ipairs({'sec','min','hour','day','month','year'}) do
        diff[v] = d2[v] - d1[v] + (carry and -1 or 0)
        carry = diff[v] < 0
        if carry then diff[v] = diff[v] + colMax[i] end
    end
    for i,v in pairs(diff) do
        script[i] = v
    end
    return diff
end -- timeDiff

---------------------------------------------
--------------- HELP FUNCTION ---------------
---------------------------------------------
function AutoInviterHelp()	
	local title = "Tallimos' AutoInviter v" .. PLUGIN_VERSION .. " Help"
	local title2 = noteline
	
	spacing = TitleSpacing(title, title2)
	
	ColourNote(help_colour, "", spacing, help_command_colour, "", title)
	
	if InviterTable["VI"] == "NO" then
		ColourNote(help_colour, "", noteline)
	elseif InviterTable["VI"] == "YES" then
		Note("")
	end
	
	ColourNote(help_colour, "", "This plugin gives the user an easy to use auto inviter with blacklist and power user options.")
	
	if InviterTable["VI"] == "NO" then
		ColourNote(help_colour, "", noteline)
	end
	
	Note("")
	
	ColourNote(help_colour, "", "Main Commands")
	
	if InviterTable["VI"] == "NO" then
		ColourNote(help_colour, "", "-------------")
	elseif InviterTable["VI"] == "YES" then
		Note("")
	end
	
	ColourNote(help_command_colour, "", "tai update                  ", help_colour, "", " - checks for the latest version of plugin and installs it")

	ColourNote(help_command_colour, "", "tai checkversion            ", help_colour, "", " - checks to see if there is a newer version of the plugin available")
	
	ColourNote(help_command_colour, "", "tai changelog               ", help_colour, "", " - displays the changelog for the plugin")

	ColourNote(help_command_colour, "", "tai enable                  ", help_colour, "", " - enables the autoinviter system")
	
	ColourNote(help_command_colour, "", "tai disable                 ", help_colour, "", " - disables the autoinviter system")
	
	ColourNote(help_command_colour, "", "tai vi                      ", help_colour, "", " - enables/disables the vi friendly option")
	
	ColourNote(help_command_colour, "", "tai bonk                    ", help_colour, "", " - enables/disables the bonk sent when someone is already in a")
	ColourNote(help_colour, "", "                               group")

	ColourNote(help_command_colour, "", "tai check <player>          ", help_colour, "", " - checks to see if player is in group or not (i.e. Talia check)")

	ColourNote(help_command_colour, "", "tai pending                 ", help_colour, "", " - shows the pending invites")
	
	ColourNote(help_command_colour, "", "tai lock                    ", help_colour, "", " - locks the group and turns off the autoinvite without disabling")
	ColourNote(help_colour, "", "                               system")
	
	ColourNote(help_command_colour, "", "tai unlock                  ", help_colour, "", " - unlocks the group and turns back on the autoinvite")
	
	ColourNote(help_command_colour, "", "tai autounlock <num>        ", help_colour, "", " - autolocks the group after group count reachs a certain point")
	Note("")
	
	ColourNote(help_colour, "", "Keyword Commands")
	
	if InviterTable["VI"] == "NO" then
		ColourNote(help_colour, "", "----------------")
	elseif InviterTable["VI"] == "YES" then
		Note("")
	end
	
	ColourNote(help_command_colour, "", "tai keywords                ", help_colour, "", " - lists your autoinvite keywords")
	
	ColourNote(help_command_colour, "", "tai keyword add <keyword>   ", help_colour, "", " - adds keyword to the keyword list. can be made up of multiple")
	ColourNote(help_colour, "", "                               words")
	
	ColourNote(help_command_colour, "", "tai keyword remove <keyword>", help_colour, "", " - remove keyword from the keyword list")
	Note("")
	
	ColourNote(help_colour, "", "Blacklist Commands")
	
	if InviterTable["VI"] == "NO" then
		ColourNote(help_colour, "", "------------------")
	elseif InviterTable["VI"] == "YES" then
		Note("")
	end

	ColourNote(help_command_colour, "", "tai bl enable               ", help_colour, "", " - enables the blacklist")
	
	ColourNote(help_command_colour, "", "tai bl disable              ", help_colour, "", " - disables the blacklist")
	
	ColourNote(help_command_colour, "", "tai bl                      ", help_colour, "", " - displays who is on the blacklist")
	
	ColourNote(help_command_colour, "", "tai bl add <player> <reason>", help_colour, "", " - adds a player to the blacklist with the option to list the")
	ColourNote(help_colour, "", "                               reason why")
	
	ColourNote(help_command_colour, "", "tai bl remove <player>      ", help_colour, "", " - remove a player from the blacklist")
	Note("")
	
	ColourNote(help_colour, "", "Power User Commands")
	
	if InviterTable["VI"] == "NO" then
		ColourNote(help_colour, "", "-------------------")
	elseif InviterTable["VI"] == "YES" then
		Note("")
	end
	
	ColourNote(help_command_colour, "", "tai pusers                  ", help_colour, "", " - lists your approved power users")
	
	ColourNote(help_command_colour, "", "tai puser enable            ", help_colour, "", " - enables the power user commands")
	
	ColourNote(help_command_colour, "", "tai puser disable           ", help_colour, "", " - disables the power user commands")
	
	ColourNote(help_command_colour, "", "tai puser add <player>      ", help_colour, "", " - adds player to power users list")
	
	ColourNote(help_command_colour, "", "tai puser remove <player>   ", help_colour, "", " - remove player from power users list")
	
	Note("")
	
	ColourNote(help_command_colour, "", "PLEASE NOTE", help_colour, "", ": For a list of power user commands, type ", help_command_colour, "", ".help", help_colour, "", " on grouptell while the Power User")
	ColourNote(help_colour, "", "system is ENABLED.")
	
	if InviterTable["VI"] == "NO" then
		ColourNote(help_colour, "", noteline)
	end
	
	Note("")
end	-- AutoInviterHelp

----------------------------------------------
--------------- SAVE FUNCTIONS ---------------
----------------------------------------------
function GetSavedData()
	if GetVariable ("aipastfirstinstall") == "true" then
		assert (loadstring (GetVariable ("InviterTable") or "")) ()

		if InviterTable["VI"] == nil then 
			InviterTable["VI"] = "NO"
		end
		
		if InviterTable["Bonk"] == nil then
			InviterTable["Bonk"] = "NO"
		end
	else
		InviterTable = {}
		InviterTable["Bonk"] = "NO"
		InviterTable["VI"] = "NO"
		InviterTable["Updating"] = "NO"
		InviterTable["BlacklistEnabled"] = false
		InviterTable["Autolock"] = false
		InviterTable["Blacklist"] = {}
		InviterTable["Pending"] = {}
		InviterTable["PowerUserEnabled"] = false
		InviterTable["Power Users"] = {}
		InviterTable["Keywords"] = {}
		-- Defaults for Shaelynne
		InviterTable["Keywords"]["invite"] = "invite"
		InviterTable["Keywords"]["invite please"] = "invite please"
		InviterTable["Keywords"]["inv"] = "inv"
		InviterTable["Keywords"]["inv please"] = "inv please"
		InviterTable["Keywords"]["invite pls"] = "invite pls"
		InviterTable["Keywords"]["please invite"] = "please invite"
	end
	
	InviterTable["Pending"] = {}
	SaveState()
end -- GetSavedData

function OnPluginInstall()
	PLUGIN_VERSION  = GetPluginInfo(GetPluginID(), 19)
	PLUGIN_NAME   = GetPluginInfo(GetPluginID(), 1)

	GetSavedData()	

	if InviterTable["Updating"] == "YES" then
		InviterTable["Updating"] = "NO"
		ColourNote(msg_colour, "", "Update complete.")
	elseif InviterTable["Updating"] == "NO" then
		ColourNote(help_colour, "", "Thank you for installing ", qty_colour, "", "Tallimos' Auto Inviter v" ..  PLUGIN_VERSION, help_colour, "", ". Please see ", help_command_colour, "", "tai help", help_colour, "", " for more information.")
	end

	Note("")
end -- OnPluginInstall

function OnPluginEnable()
	GetSavedData()	
end -- OnPluginEnable

function OnPluginSaveState()
	SetVariable ("InviterTable", "InviterTable = " .. serialize.save_simple (InviterTable))
	SetVariable ("aipastfirstinstall", "true")
end -- OnPluginSaveState

-- Changelog code courtesy of Durel
pluginId        = "2dae6923b0384dba4ddff81f"

dbot = {}
----------------------------------------------------------------------------------------------------
-- dbot.version: Track the plugin's version and changelog and update the plugin 
--
-- dbot.version.changelog.get(minVersion, endTag)
-- dbot.version.changelog.getCR()
-- dbot.version.changelog.displayChanges(minVersion, changeLog)
-- dbot.version.changelog.displayChange(changeLogEntries)
--
-- dbot.version.update.release(mode, endTag)
-- dbot.version.update.releaseCR()
-- Note: dbot.version.update is derived from a plugin written by Arcidayne.  Thanks Arcidayne!
----------------------------------------------------------------------------------------------------

dbot.version               = {}

dbot.version.changelog     = {}
dbot.version.changelog.pkg = nil

dbot.version.update        = {}
dbot.version.update.pkg    = nil

drlDbotUpdateCheck         = "check"
drlDbotUpdateInstall       = "install"

drlDbotChangeLogTypeFix    = "@RFix@W"
drlDbotChangeLogTypeNew    = "@GNew@W"
drlDbotChangeLogTypeMisc   = "@yMsc@W"

function dbot.version.changelog.get(minVersion, endTag)
  local url      = "https://raw.githubusercontent.com/tallimos/AardPlugins/main/AutoInviter/autoinviter.changelog"
  local protocol = "HTTPS"

  if (dbot.version.changelog.pkg ~= nil) then
    Note("Skipping changelog request: another request is in progress")
  end -- if

  dbot.version.changelog.pkg            = {}
  dbot.version.changelog.pkg.url        = url
  dbot.version.changelog.pkg.protocol   = protocol
  dbot.version.changelog.pkg.minVersion = minVersion or 0
  dbot.version.changelog.pkg.endTag     = endTag
 
  dbot.version.changelog.getCR()
end -- dbot.version.changelog.get

function dbot.version.changelog.getCR()

  if (dbot.version.changelog.pkg == nil) then
    dbot.print("dbot.version.changelog.getCR: Change log package is missing!")
  end -- if

  local fileData = dbot.remote.get(dbot.version.changelog.pkg.url,
                                           dbot.version.changelog.pkg.protocol)
	if (fileData == nil) then
    dbot.print("@DNo changelog information was found. Please report to @CTallimos@D.")

  else
    loadstring(fileData)()
    if (dbot.changelog == nil) then
      dbot.print("dbot.version.changelog.getCR: Invalid changelog format detected")
    else
      dbot.version.changelog.displayChanges(dbot.version.changelog.pkg.minVersion, dbot.changelog)
    end -- if
  end -- if

  dbot.version.changelog.pkg = nil
end -- dbot.version.changelog.getCR

function dbot.version.changelog.displayChanges(minVersion, changeLog)
  local sortedLog = {}

  for k, v in pairs(changeLog) do
    table.insert(sortedLog, { version = tonumber(k) or 0, changes = v})
  end -- for
  table.sort(sortedLog, function (v1, v2) return v1.version < v2.version end)

  for _, clog in ipairs(sortedLog) do
    if (clog.version > minVersion) then
      dbot.version.changelog.displayChange(clog)
    end -- if
  end -- for

end -- dbot.version.changelog.displayChanges

-- Format of entry is: { version = 2.13,
--                       changes = { { change = drlDbotChangeLogTypeXYZ, desc = "what changed" }
--                                 }
--                     }
function dbot.version.changelog.displayChange(changeLogEntries)

  if (changeLogEntries == nil) then
    dbot.print("dbot.version.changelog.displayChange: Change entries are missing!")
    return
  end -- if

  dbot.print(string.format("@Cv%1.2f@W", changeLogEntries.version))
  for _, logEntry in ipairs(changeLogEntries.changes) do
    dbot.print(string.format("@W    (%s): %s", logEntry.change, logEntry.desc))
  end -- for
end -- dbot.version.changelog.displayChange

function dbot.version.update.release(mode, endTag)
  local url      = "https://raw.githubusercontent.com/tallimos/AardPlugins/main/AutoInviter/Tallimos_AutoInviter.xml"
  local protocol = "HTTPS"
  local retval   = DRL_RET_SUCCESS

  if (mode == nil) or ((mode ~= drlDbotUpdateCheck) and (mode ~= drlDbotUpdateInstall)) then
    dbot.print("dbot.version.update.release: Missing or invalid mode parameter")
  end -- if

  if (dbot.version.update.pkg ~= nil) then
    Note("Skipping update request: another update request is in progress")
  end -- if

  dbot.version.update.pkg          = {}
  dbot.version.update.pkg.mode     = mode
  dbot.version.update.pkg.url      = url
  dbot.version.update.pkg.protocol = protocol
  dbot.version.update.pkg.endTag   = endTag

	dbot.version.update.releaseCR()	
  return retval
end -- dbot.version.update.release

function dbot.version.update.releaseCR()

  if (dbot.version.update.pkg == nil) or (dbot.version.update.pkg.mode == nil) then
    dbot.error("dbot.version.update.releaseCR: Missing or invalid update package detected")
  end -- if

  local endTag = dbot.version.update.pkg.endTag

  -- This blocks until the plugin file is returned, an error is detected, or we time out
  local pluginData, retval = dbot.remote.get(dbot.version.update.pkg.url, dbot.version.update.pkg.protocol)
  if (retval ~= DRL_RET_SUCCESS) then
    dbot.print("dbot.version.update.releaseCR: Failed to retrieve latest plugin file: " ..
              dbot.retval.getString(retval))

  elseif (pluginData == nil) then
    dbot.print("@DCould not find a remote plugin release")
    retval = DRL_RET_MISSING_ENTRY

  else
    local currentVersion = GetPluginInfo(GetPluginID(), 19) or 0
    local currentVerStr  = string.format("%1.2f", currentVersion)
    local remoteVerStr   = string.match(pluginData, '%s%s+version="([0-9%.]+)"')
    local remoteVersion  = tonumber(remoteVerStr or "") or 0

    if (remoteVersion == currentVersion) then
      dbot.print("@DYou are running the latest version of the plugin (v@C" .. currentVerStr .. "@D)")

    elseif (remoteVersion < currentVersion) then
      dbot.print("@DYour current plugin (v@C" .. currentVerStr .. "@D) " ..
                "is newer than the latest official release (v@C" .. remoteVerStr .. "@D)")
      retval = DRL_RET_VER_MISMATCH

    elseif (dbot.version.update.pkg.mode == drlDbotUpdateCheck) then
      dbot.print("@DYou are running v@C" .. currentVerStr .. "@D, latest version is v@C" .. remoteVerStr)
      dbot.print("@DChanges since your last update:")
      dbot.version.update.pkg = nil
      return dbot.version.changelog.get(currentVersion, endTag)

    elseif (dbot.version.update.pkg.mode == drlDbotUpdateInstall) then
      dbot.print("@DUpdating plugin from version @C" .. currentVerStr .. " @Dto version @C" .. remoteVerStr) 
      dbot.print("@DPlease wait until the update is complete.")

      local pluginFile = GetPluginInfo(GetPluginID(), 6)
      local file = io.open(pluginFile, "w")
      file:write(pluginData)
      file:close()
	  
	  dbot.reload()
    else
      dbot.print("@Ddbot.version.update.callback: Detected invalid mode \"@R" ..
                 (dbot.version.update.pkg.mode or "nil") .. "@W\"")
    end -- if

  end -- if

  dbot.version.update.pkg = nil

end -- dbot.version.update.releaseCR

----------------------------------------------------------------------------------------------------
-- Module to retrieve remote files
--
-- dbot.remote.get(url, protocol)
-- dbot.remote.getCR()
--
----------------------------------------------------------------------------------------------------

dbot.remote        = {}
dbot.remote.getPkg = nil

-- Blocks and then returns file, retval
-- Must be called from within a co-routine
function dbot.remote.get(url, protocol)
  local retval   = DRL_RET_SUCCESS
  local fileData = nil

  if (url == nil) or (url == "") then
    dbot.print("dbot.remote.get: missing url parameter")
    return fileData, DRL_RET_INVALID_PARAMETER
  end -- if

  if (protocol == nil) or (protocol == "") then
    dbot.print("dbot.remote.get: missing protocol parameter")
    return fileData, DRL_RET_INVALID_PARAMETER
  end -- if

  if (dbot.remote.getPkg ~= nil) then
    dbot.info("Skipping remote request: another request is in progress")
    return fileData, DRL_RET_BUSY
  end -- if

  dbot.remote.getPkg          = {}
  dbot.remote.getPkg.url      = url
  dbot.remote.getPkg.protocol = protocol
  dbot.remote.getPkg.isDone   = false

	dbot.remote.getCR()
  local timeout = 10
  local totTime = 0
  while (dbot.remote.getPkg.isDone == false) do
    if (totTime > timeout) then
      break
    end -- if
  end -- while

  if (dbot.remote.getPkg ~= nil) and (dbot.remote.getPkg.fileData ~= nil) then
    fileData = dbot.remote.getPkg.fileData
  else
    dbot.print("@DFailed to find data for file\n \"@C" .. url .. "@W\"")
  end -- if

  dbot.remote.getPkg = nil
  return fileData

end -- dbot.remote.get

function dbot.remote.getCR()
  if (dbot.remote.getPkg == nil) or (dbot.remote.getPkg.url == nil) then
    dbot.error("dbot.remote.getCR: remote package is nil or corrupted!")
    dbot.remote.getPkg = nil
    return 
  end -- if

  local urlThread = async.request(dbot.remote.getPkg.url, dbot.remote.getPkg.protocol)

  if (urlThread == nil) then
    dbot.print("dbot.remote.getCR: Failed to create thread requesting remote data")

  else
    local timeout = 10
    local totTime = 0
    while (urlThread:alive()) do
      if (totTime > timeout) then
        break
      end -- if
    end -- while

    local remoteRet, page, status, headers, fullStatus = urlThread:join()

    if (status ~= 200) then
      dbot.print("@DFailed to retrieve remote file")
    else
      dbot.remote.getPkg.fileData = page
    end -- if

    dbot.remote.getPkg.isDone = true

  end -- if
end -- dbot.remote.getCR

function dbot.print(string)
    AnsiNote(stylesToANSI(ColoursToStyles(string)))
end -- dbot.print

----------------------------------------------------------------------------------------------------
-- dbot.reload: Reloads the current plugin
--
-- Note: This code was derived from part of a plugin by Arcidayne.  Thanks Arcidayne!
----------------------------------------------------------------------------------------------------

function dbot.reload()
  local scriptPrefix = GetAlphaOption("script_prefix")
  local retval

  -- If the user has not already specified the script prefix for this version of mush, pick a
  -- reasonable default value
  if (scriptPrefix == "") then
    scriptPrefix = "\\\\\\"
    SetAlphaOption("script_prefix", scriptPrefix)
  end

  -- Tell mush to reload the plugin in one second.  We can't do it directly here because a
  -- plugin can't unload itself.  Even if it could, how could it tell mush to load it again
  -- if it weren't installed? 
  retval = Execute(scriptPrefix.."DoAfterSpecial(1, \"ReloadPlugin('"..GetPluginID().."')\", sendto.script)")
  if (retval ~= 0) then
    dbot.print("@Ddbot.reload: Failed to reload the plugin: mush error " .. retval)
  end -- if
end -- dbot.reload

-- Update code taken from Pwars installer menu
function tai_update(name, line, wc)
	printmsg("*** Checking if update is available for Tallimos' Auto Inviter.. Please wait.\r\n\r\n")
	local url = "https://raw.githubusercontent.com/tallimos/AardPlugins/main/AutoInviter/Tallimos_AutoInviter.xml"
	async.doAsyncRemoteRequest(url, async_tai_download_complete, "HTTPS", 120)
end

function tai_install(name, line, wc)
   for p = 1, #pluginList do
      if pluginList[p] ~= nil and tonumber(wc.index) == p then
         printmsg("Attempting to install plugin #" .. wc.index .. " (" .. pluginList[p].name .. ")")
         install_plugin(pluginList[p])
      end
   end
   if #pluginList == 0 then
      printmsg("Error: Unable to read plugin index.")
   end
end

function async_tai_download_complete(retval, page, status, headers, full_status, request_url)
  if status == 200 then
    local version = tonumber(string.match(page, '%s%s+version="([0-9%.]+)"'))
    local installedVer = GetPluginInfo(GetPluginID(), 19)
    if version > installedVer then
      printmsg("Updating from version " .. installedVer .. " to version " .. version)
      local file = io.open(GetPluginInfo(GetPluginID(), 6), "w")
      page = string.gsub(page, "\r", "")
      file:write(page)
      file:close()
      if GetAlphaOption("script_prefix") == "" then SetAlphaOption("script_prefix", "\\\\\\") end
      Execute(GetAlphaOption("script_prefix").."DoAfterSpecial(1, \"ReloadPlugin('"..GetPluginID().."')\", sendto.script)")
    else
      printmsg("You already have the latest version of Tallimos' AutoInviter installed.")
    end
  else
      printmsg("Plugin update check failed...Error " .. tostring(status))
  end
end

function async_plugin_download_complete(retval, page, status, headers, full_status, request_url)
   local folder
   local xmlFiles = {}
   local xmlFile = {}
   if updatePlugin.installpath == "1" then
      folder = GetInfo(66)
   else
      folder = GetPluginInfo(GetPluginID(), 20)
   end
   if status == 200 then -- download successful
      printmsg("----------------------------------------------")
      printmsg("*** " .. updatePlugin.name .. " download successful.")
      f = assert(io.open (folder .. "temp_update.zip", "wb"))
      f:write(page)
      f:close()
      local zfile, err = zip.open(folder .. "temp_update.zip")
      printmsg("Extracting files from zip:")
      for file in zfile:files() do
         local currFile, err = zfile:open(file.filename)
         local currFileContents = currFile:read("*a") -- read entire contents of current file
         local hBinaryOutput = io.open(folder .. file.filename, "wb")
          -- write current file inside zip to a file outside zip
          if(hBinaryOutput)then
              hBinaryOutput:write(currFileContents)
              hBinaryOutput:close()
          end
         printmsg("(+) " .. file.filename)
         local fileExt = string.sub(file.filename, -4)
         if fileExt == ".xml" then
            xmlFile.filename = file.filename
            xmlFile.pluginid = string.match(currFileContents, '%s%s+id="(.-)"')            
            table.insert(xmlFiles, xmlFile)
            xmlFile = {}
         end
         currFile:close()
      end
      os.remove(folder .. "temp_update.zip")
      printmsg("Update succeeded, loading/reloading plugins.")
      printmsg("----------------------------------------------")
      for i = 1, #updatePlugin.ids do

      end
      for i = 1, #xmlFiles do

         if not (IsPluginInstalled(xmlFiles[i].pluginid) and GetPluginInfo(xmlFiles[i].pluginid, 17)) then
            LoadPlugin(folder .. xmlFiles[i].filename)
         else
            ReloadPlugin(xmlFiles[i].pluginid)
         end
         installedPlugins[xmlFiles[i].pluginid] = headers["etag"]
      end
      SaveState()
   else
      printmsg("Plugin download failed...Error " .. tostring(status))

   end
   updatePlugin = {}
   xmlFiles = {}
end

function async_xml_download_complete(retval, page, status, headers, full_status, request_url)
   if status == 200 then
      --print(page)
      --print(status)
      lastListHash = headers["etag"]
      SaveState()
      local xml = utils.xmlread(page)
      local num_plugins = #xml.nodes [2].nodes
      --print(num_plugins)
      pluginList = {}
      for p = 1,num_plugins do
         num_plugin_nodes = #xml.nodes [2].nodes [p].nodes
         local thisPlugin = {}
         thisPlugin.ids = {}
         for n = 1, num_plugin_nodes do
            local xmlkey = xml.nodes [2].nodes [p].nodes [n].name
            local xmlval = xml.nodes [2].nodes [p].nodes [n].content
            if xmlkey == "name" then thisPlugin.name = xmlval
            elseif xmlkey == "author" then thisPlugin.author = xmlval
            elseif xmlkey == "description" then thisPlugin.description = xmlval
            elseif xmlkey == "id" then table.insert(thisPlugin.ids, xmlval)
            elseif xmlkey == "download" then thisPlugin.download = xmlval
            elseif xmlkey == "installpath" then thisPlugin.installpath = xmlval
            end
         end
         require "tprint"
         pluginList[p] = thisPlugin
         thisPlugin.installed = true
         for i = 1, #thisPlugin.ids do
            if not (IsPluginInstalled(thisPlugin.ids[i]) and GetPluginInfo(thisPlugin.ids[i], 17)) then
               thisPlugin.installed = false
               --print("Plugin not installed and enabled!!" .. thisPlugin.ids[i])
            end
         end
      end
      lastPluginList = pluginList
      SaveState()
      for p = 1, #pluginList do
         get_plugin_info(pluginList[p])
      end
   else
      printmsg("Downloading plugin list failed...Error " .. tostring(status))
   end
end

function get_plugin_info(plugin)
   local http_mode = string.sub(plugin.download, 1, 5)
   if http_mode == "https" then
      http_mode = string.upper(http_mode)
   else
      http_mode = "HTTP"
   end
   async.HEAD(plugin.download, async_head_plugin, http_mode, 120)
end

function install_plugin(plugin)
   --print("plugin.ids[1]: " .. plugin.ids[1])
   url = plugin.download
   local http_mode = string.sub(url, 1, 5)
   if http_mode == "https" then
      http_mode = string.upper(http_mode)
   else
      http_mode = "HTTP"
   end
   updatePlugin = plugin
   async.doAsyncRemoteRequest(url, async_plugin_download_complete, http_mode, 120)
end

function printmsg(msg)
   ColourNote("cornflowerblue", "", msg)
end

]]>
</script> 
</muclient>