	<?xml version="1.0" encoding="iso-8859-1"?>
<!DOCTYPE muclient>
<!-- Saved on Friday, December 11, 2020, 9:37 PM -->
<!-- MuClient version 5.07-pre -->

<!-- Plugin "Tallimos_Epic_Broadcaster" generated by Plugin Wizard -->

<muclient>
<plugin
   name="Utility_TEBBroadcaster"
   author="Tallimos"
   id="ee9c79343749c58f7d1e99bc"
   language="Lua"
   purpose="Easy to use broadcaster for epic runs"
   save_state="y"
   date_written="2020-12-11 21:36:19"
   requires="4.36"
   version="1.81"
   >

</plugin>

<!--  Get our standard constants -->

<include name="constants.lua"/>

<!--  Triggers  -->
<triggers>
</triggers>

<!--  Timers  -->
<timers>
	<timer
		name="Broadcaster" 
		minute="3"  
		enabled="n"
		script="Broadcaster"
		>
	</timer>
</timers>

<!--  Aliases  -->

<aliases>
	<alias
		script="CommandMenu"
		match="^(?:teb|tebroad|tepicbroad) (.*?)$"
		enabled="y"
		ignore_case="y"
		regexp="y"
		sequence="100"
		>
	</alias>
	<alias
		script="SetColour"
		match="^(?:teb|tebroad|tepicbroad) setcolour (.*?)$"
		enabled="y"
		ignore_case="y"
		regexp="y"
		sequence="90"
		>
	</alias>
</aliases>

<script>
<![CDATA[
require "tprint"
require "mw_theme_base"
require "serialize"
require "commas"
require "gmcphelper"
require "copytable"
require "aardmapper"
require "aard_lua_extras"
require "wait"
require "async"

local channel_colour   = "yellow"
local msg_colour      = "lightslategrey"
local err_colour      = "firebrick"
local help_colour     = "lightslategrey"
local qty_colour      = "cyan"
local optional_colour = "lightcoral"
local command_colour  = "white"
local cmd_required    = "royalblue"
local help_command_colour  = "red"

local noteline = "=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-="

---------------------------------------------
--------------- MENU FUNCTION ---------------
---------------------------------------------
function CommandMenu(name, line, wc)
	commandline = trim(string.lower(wc[1]))
	wordtable = utils.split (commandline, " ")

	cmd = wordtable[1]
	
	if cmd == "enable" then
		if wordtable[2] ~= nil then
			channel = wordtable[2]

			if BroadcastTable["Channels"][channel] == nil then
				ColourNote(qty_colour, "", channel, msg_colour, "", " has not been be added to the broadcast list")
			else
				if BroadcastTable["Channels"][channel] == true then 
					ColourNote(msg_colour, "", "Broadcasting for ", qty_colour, "", channel, msg_colour, "", " has already been enabled.")
				else
					ColourNote(msg_colour, "", "Broadcasting for ", qty_colour, "", channel, msg_colour, "", " has been enabled.")
					BroadcastTable["Channels"][channel] = true
				end
			end
		else
			ColourNote(msg_colour, "", "Please input a channel to enable")
		end
	elseif cmd == "disable" then
		if wordtable[2] ~= nil then
			channel = wordtable[2]
			
			if BroadcastTable["Channels"][channel] == nil then
				ColourNote(qty_colour, "", channel, msg_colour, "", " has not been be added to the broadcast list")
			else
				if BroadcastTable["Channels"][channel] == false then 
					ColourNote(msg_colour, "", "Broadcasting for ", qty_colour, "", channel, msg_colour, "", " has already been disabled.")
				else
					ColourNote(msg_colour, "", "Broadcasting for ", qty_colour, "", channel, msg_colour, "", " has been disabled.")
					BroadcastTable["Channels"][channel] = false
				end
			end
		else
			ColourNote(msg_colour, "", "Please input a channel to disable")
		end
	elseif cmd == "abort" or cmd == "off" or cmd == "cancel" then
		check (EnableTimer ("Broadcaster", 0))
		ColourNote(msg_colour, "", "Broadcasting has been turned off.")
	elseif cmd == "broadcast" then
		if wordtable[2] ~= nil then
			ename = wordtable[2]
			btime = nil
			optmsg = nil
			
			wordcount = 0
			
			for i,v in ipairs(wordtable) do
				wordcount = wordcount + 1
			end
			
			if CheckEpic(ename) ~= nil then
				if tonumber(wordtable[3]) ~= nil then
					btime = tonumber(wordtable[3])

					if wordtable[4] ~= nil then
						for x = 4, wordcount, 1 do
							if optmsg == nil then
								optmsg = wordtable[x]
							else
								optmsg = optmsg .. " " .. wordtable[x]
							end
						end
					end
				elseif wordtable[3] ~= nil then
					for x = 3, wordcount, 1 do
						if optmsg == nil then
							optmsg = wordtable[x]
						else
							optmsg = optmsg .. " " .. wordtable[x]
						end
					end
				end	
				
				EnableBroadcast(ename, btime, optmsg)
			else
				ColourNote(msg_colour, "", "Please enter a valid epic name.")
				Note("")
				ColourNote(msg_colour, "", "Valid options are: ", qty_colour, "", "genie", msg_colour, "", ", ", qty_colour, "", "if1", msg_colour, "", ", ", qty_colour, "", "if2", msg_colour, "", ", ", qty_colour, "", "inferno", msg_colour, "", ", ", qty_colour, "", "oc", msg_colour, "", ", ", qty_colour, "", "winds", msg_colour, "", ", ", qty_colour, "", "titan", msg_colour, "", ", ", qty_colour, "", "terra", msg_colour, "", ", ", qty_colour, "", "oldvanir", msg_colour, "", ", ", qty_colour, "", "testmaze10", msg_colour, "", " and ", qty_colour, "", "trans")
			end
		else
			ColorNote(msg_colour, "", "Invalid option. Please see ", qty_colour, "", "teb help", msg_colour, "", " for more information")
		end
	elseif cmd == "settimer" then
		if tonumber(wordtable[2]) ~= nil then
			minutes = tonumber(wordtable[2])
			SetTimerOption ("Broadcaster", "minute", minutes)
			BroadcastTable["TimerMinutes"] = minutes
			
			ColourNote(msg_colour, "", "Broadcast timer set to ", qty_colour, "", BroadcastTable["TimerMinutes"], msg_colour, "", " minutes.")
		else
			ColourNote(msg_colour, "", "Please input a number of minutes")
		end		
	elseif cmd == "namedisplay" then
		if BroadcastTable["DisplayNameType"] == "FullName" then
			BroadcastTable["DisplayNameType"] = "ShortName"
			name = BroadcastTable["Epics"]["genie"]["ShortName"]
			ColourNote(msg_colour, "", "Epic name display type changed to ", qty_colour, "", "ShortName", msg_colour, "", " (genie will appear as ", qty_colour, "", name, msg_colour, "", ")")
		elseif BroadcastTable["DisplayNameType"] == "ShortName" then
			BroadcastTable["DisplayNameType"] = "FullName"
			name = BroadcastTable["Epics"]["genie"]["FullName"]
			ColourNote(msg_colour, "", "Epic name display type changed to ", qty_colour, "", "FullName", msg_colour, "", " (genie will appear as ", qty_colour, "", name, msg_colour, "", ")")
		end
	elseif cmd == "setdisplay" then
		if tonumber(wordtable[2]) ~= nil then
			displaynum = tonumber(wordtable[2])
			
			if displaynum >= 1 and displaynum <= 40 then
				BroadcastTable["DisplayType"] = displaynum
				ColourNote(msg_colour, "", "Display type changed to ", qty_colour, "", displaynum)
				Execute ("teb sample")
			else
				ColourNote(msg_colour, "", "Please input a number between 1 and 40")
			end
		else
			ColourNote(msg_colour, "", "Please input a number between 1 and 40")
		end
	elseif cmd == "sample" then
		if tonumber(wordtable[2]) ~= nil then
			displaynum = tonumber(wordtable[2])
			
			if displaynum >= 1 and displaynum <= 40 then
				currentdisplay = BroadcastTable["DisplayType"]	
				BroadcastTable["DisplayType"] = displaynum
			
				GetCharName()
				bcolour = BroadcastTable["Epics"]["genie"]["Colour"]
				charname = string.gsub (charname, "^.", string.upper)
				
				if BroadcastTable["DisplayNameType"] == "FullName" then
					broadcastname = BroadcastTable["Epics"]["genie"]["FullName"]
				elseif BroadcastTable["DisplayNameType"] == "ShortName" then
					broadcastname = BroadcastTable["Epics"]["genie"]["ShortName"]
				end
				
				sample = MakeMessage(bcolour, broadcastname, charname)
				SendNoEcho("echo @CSample message (display type " .. displaynum .. "): " .. sample)
				
				BroadcastTable["DisplayType"] = currentdisplay
			else
				ColourNote(msg_colour, "", "Please input a number between 1 and 40")
			end
		elseif wordtable[2] ~= nil then
			ename = wordtable[2]
			
			if CheckEpic(ename) ~= nil then
				bcolour = BroadcastTable["Epics"][ename]["Colour"]

				if BroadcastTable["DisplayNameType"] == "FullName" then
					broadcastname = BroadcastTable["Epics"][ename]["FullName"]
				elseif BroadcastTable["DisplayNameType"] == "ShortName" then
					broadcastname = BroadcastTable["Epics"][ename]["ShortName"]
				end
				
				SendNoEcho("echo @R" .. ename .. " @Dwill appear as " .. bcolour .. broadcastname)
			else
				ColourNote(msg_colour, "", "Please enter a valid epic name.")
				Note("")
				ColourNote(msg_colour, "", "Valid options are: ", qty_colour, "", "genie", msg_colour, "", ", ", qty_colour, "", "if1", msg_colour, "", ", ", qty_colour, "", "if2", msg_colour, "", ", ", qty_colour, "", "inferno", msg_colour, "", ", ", qty_colour, "", "oc", msg_colour, "", ", ", qty_colour, "", "winds", msg_colour, "", ", ", qty_colour, "", "titan", msg_colour, "", ", ", qty_colour, "", "terra", msg_colour, "", ", ", qty_colour, "", "oldvanir", msg_colour, "", ", ", qty_colour, "", "testmaze10", msg_colour, "", " and ", qty_colour, "", "trans")
			end
		else
			GetCharName()
			bcolour = BroadcastTable["Epics"]["genie"]["Colour"]
			charname = string.gsub (charname, "^.", string.upper)
			
			if BroadcastTable["DisplayNameType"] == "FullName" then
				broadcastname = BroadcastTable["Epics"]["genie"]["FullName"]
			elseif BroadcastTable["DisplayNameType"] == "ShortName" then
				broadcastname = BroadcastTable["Epics"]["genie"]["ShortName"]
			end
				
			sample = MakeMessage(bcolour, broadcastname, charname)
			SendNoEcho("echo @CSample message (current settings): " .. sample)
		end
	elseif cmd == "list" then
		ListChannels()
	elseif cmd == "vi" then		
		if BroadcastTable["VI"] == "YES" then
			BroadcastTable["VI"] = "NO"
			ColourNote(msg_colour, "", "VI friendy option disabled.")
		elseif BroadcastTable["VI"] == "NO" then
			BroadcastTable["VI"] = "YES"
			ColourNote(msg_colour, "", "VI friendy option enabled.")			
		end
	elseif cmd == "update" then
		-- dbot.version.update.release(drlDbotUpdateInstall, endTag)
		teb_update()
		BroadcastTable["Updating"] = "YES"
	elseif cmd == "changelog" then
		dbot.print("@DFull changelog:")
		dbot.version.changelog.get(0, endTag) -- show changelog from version 0 to the latest
	elseif cmd == "checkversion" then
		dbot.version.update.release(drlDbotUpdateCheck, endTag)
	elseif cmd == "help" then
		EpicBroadcasterHelp()
	else
		ColourNote(msg_colour, "", "Invalid command. Please see ", qty_colour, "", "teb help", msg_colour, "", " for more information.")
	end
	
	SaveState()
end -- CommandMenu

function SetColour(name, line, wc)
	commandline = trim(wc[1])
	wordtable = utils.split (commandline, " ")

	if wordtable[1] ~= nil then
		ename = string.lower(wordtable[1])
	
		if CheckEpic(ename) ~= nil then
			for xcolour in wordtable[2]:gmatch("%@x%d+") do	
				for xct in xcolour:gmatch("%d+") do	
					if tonumber(xct) < 0 or tonumber(xct) > 255 then
						ColourNote(msg_colour, "", "Valid xterm colors are ", qty_colour, "", "000", msg_colour, "", "-", qty_colour, "", "255")
						
						return
					end
				end
				
				bcolour = xcolour
				BroadcastTable["Epics"][ename]["Colour"] = bcolour
				ColourNote(msg_colour, "", "Colour for ", qty_colour, "", ename, msg_colour, "", " has been set to ", qty_colour, "", bcolour)
				
				SaveState()
				
				return
				
				
			end
			
			for colour in wordtable[2]:gmatch("%@%a") do	
				bcolour = colour
				BroadcastTable["Epics"][ename]["Colour"] = bcolour
				ColourNote(msg_colour, "", "Colour for ", qty_colour, "", ename, msg_colour, "", " has been set to ", qty_colour, "", bcolour)
			end			
			
			if bcolour == nil then 
				ColourNote(msg_colour, "", "Please enter a valid colour code, i.e. ", qty_colour, "", "@C")
				return
			end
		else
			ColourNote(msg_colour, "", "Please enter a valid epic name.")
			Note("")
			ColourNote(msg_colour, "", "Valid options are: ", qty_colour, "", "genie", msg_colour, "", ", ", qty_colour, "", "if1", msg_colour, "", ", ", qty_colour, "", "if2", msg_colour, "", ", ", qty_colour, "", "inferno", msg_colour, "", ", ", qty_colour, "", "oc", msg_colour, "", ", ", qty_colour, "", "winds", msg_colour, "", ", ", qty_colour, "", "titan", msg_colour, "", ", ", qty_colour, "", "terra", msg_colour, "", ", ", qty_colour, "", "oldvanir", msg_colour, "", ", ", qty_colour, "", "testmaze10", msg_colour, "", " and ", qty_colour, "", "trans")
		end
	else
		ColourNote(msg_colour, "", "Command usage: ", qty_colour, "", "teb setcolour <epicname> <colourcode>")
	end
	
	SaveState()
end

function EnableBroadcast(ename, btime, optmsg)
	repeats = nil
	rindex = 0

	GetCharName()	
	
	if BroadcastTable["DisplayNameType"] == "FullName" then
		broadcastname = BroadcastTable["Epics"][ename]["FullName"]
	elseif BroadcastTable["DisplayNameType"] == "ShortName" then
		broadcastname = BroadcastTable["Epics"][ename]["ShortName"]
	end

	bcolour = BroadcastTable["Epics"][ename]["Colour"]

	charname = string.gsub (charname, "^.", string.upper)
	
	message = MakeMessage(bcolour, broadcastname, charname)
		
	if optmsg ~= nil then
		message = message .. " @G" .. optmsg
	end
	
	if btime ~= nil then
		tminute = GetTimerOption ("Broadcaster", "minute")
	
		repeats = math.floor(btime / tminute)
	end
	
	if repeats ~= nil then 
		check (EnableTimer ("Broadcaster", 1))
		check (ResetTimer ("Broadcaster"))
	end
	
	Broadcaster()
end

function Broadcaster()
	if repeats ~= nil then
		
		rindex = rindex + 1
		
		for i,v in pairs(BroadcastTable["Channels"]) do
			if v == true then
				rchan = i
				
				SendNoEcho(rchan .. " " .. message .. "@w")
			end
		end

		if rindex == repeats then
			message = message .. " @W<<< @CLAST CALL @W>>>"
		end
		
		if rindex > repeats then
			check (EnableTimer ("Broadcaster", 0))
			return
		end
	else
		for i,v in pairs(BroadcastTable["Channels"]) do
			if v == true then
				SendNoEcho(i .. " " .. message .. "@w")
			end
		end
	end
end -- Broadcaster

function MakeMessage(bcolour, broadcastname, charname)
	if BroadcastTable["DisplayType"] == 1 then
		emsg = "@DGrouping for " .. bcolour .. broadcastname .. "@D. Please send '@Cinvite@D' tell to @R" .. charname .. " @Dto join.@w"
	elseif BroadcastTable["DisplayType"] == 2 then
		emsg = "@DGrouping for " .. bcolour .. broadcastname .. "@D. Please send tells to @R" .. charname .. " @Dto join.@w"
	elseif BroadcastTable["DisplayType"] == 3 then
		emsg = "@DGrouping for " .. bcolour .. broadcastname .. "@D. Send '@Cinvite@D' tell to @R" .. charname .. " @Dto join.@w"
	elseif BroadcastTable["DisplayType"] == 4 then
		emsg = "@DGrouping for " .. bcolour .. broadcastname .. "@D. Send tells to @R" .. charname .. " @Dto join.@w"
	elseif BroadcastTable["DisplayType"] == 5 then
		emsg = bcolour .. broadcastname .. " @Dgroup forming." .. "@D. Send '@Cinvite@D' tell to @R" .. charname .. " @Dto join.@w"
	elseif BroadcastTable["DisplayType"] == 6 then
		emsg = bcolour .. broadcastname .. " @Dgroup forming." .. "@D. Send tells to @R" .. charname .. " @Dto join.@w"
	elseif BroadcastTable["DisplayType"] == 7 then
		emsg = "@R<<<@DGrouping for " .. bcolour .. broadcastname .. "@D, send '@Cinvite@D' tell to @R" .. charname .. "@R>>>@w"
	elseif BroadcastTable["DisplayType"] == 8 then
		emsg = "@R<<<@DGrouping for " .. bcolour .. broadcastname .. "@D. send tells to @R" .. charname .. "@R>>>@w"
	elseif BroadcastTable["DisplayType"] == 9 then
		emsg = "@R<<<" .. bcolour .. broadcastname .. " @Dgroup forming." .. "@D, send '@Cinvite@D' tell to @R" .. charname .. "@R>>>@w"
	elseif BroadcastTable["DisplayType"] == 10 then
		emsg = "@R<<<" .. bcolour .. broadcastname .. " @Dgroup forming." .. "@D, send tells to @R" .. charname .. "@R>>>@w"
	elseif BroadcastTable["DisplayType"] == 11 then
		emsg = "@R[EBroad] @DGrouping for " .. bcolour .. broadcastname .. "@D. Please send '@Cinvite@D' tell to @R" .. charname .. " @Dto join.@w"
	elseif BroadcastTable["DisplayType"] == 12 then
		emsg = "@R[EBroad] @DGrouping for " .. bcolour .. broadcastname .. "@D. Please send tells to @R" .. charname .. " @Dto join.@w"
	elseif BroadcastTable["DisplayType"] == 13 then
		emsg = "@R[EBroad] @DGrouping for " .. bcolour .. broadcastname .. "@D. Send '@Cinvite@D' tell to @R" .. charname .. " @Dto join.@w"
	elseif BroadcastTable["DisplayType"] == 14 then
		emsg = "@R[EBroad] @DGrouping for " .. bcolour .. broadcastname .. "@D. Send tells to @R" .. charname .. " @Dto join.@w"
	elseif BroadcastTable["DisplayType"] == 15 then
		emsg = "@R[EBroad] " .. bcolour .. broadcastname .. " @Dgroup forming." .. "@D. Send '@Cinvite@D' tell to @R" .. charname .. " @Dto join.@w"
	elseif BroadcastTable["DisplayType"] == 16 then
		emsg = "@R[EBroad] " .. bcolour .. broadcastname .. " @Dgroup forming." .. "@D. Send tells to @R" .. charname .. " @Dto join.@w"
	elseif BroadcastTable["DisplayType"] == 17 then
		emsg = "@R[EBroad] <<<@DGrouping for " .. bcolour .. broadcastname .. "@D, send '@Cinvite@D' tell to @R" .. charname .. "@R>>>@w"
	elseif BroadcastTable["DisplayType"] == 18 then
		emsg = "@R[EBroad] <<<@DGrouping for " .. bcolour .. broadcastname .. "@D. send tells to @R" .. charname .. "@R>>>@w"
	elseif BroadcastTable["DisplayType"] == 19 then
		emsg = "@R[EBroad] <<<" .. bcolour .. broadcastname .. " @Dgroup forming." .. "@D, send '@Cinvite@D' tell to @R" .. charname .. "@R>>>@w"
	elseif BroadcastTable["DisplayType"] == 20 then
		emsg = "@R[EBroad] <<<" .. bcolour .. broadcastname .. " @Dgroup forming." .. "@D, send tells to @R" .. charname .. "@R>>>@w"
	elseif BroadcastTable["DisplayType"] == 21 then
		emsg = "@DGrouping for @C(Mentor) " .. bcolour .. broadcastname .. "@D. Please send '@Cinvite@D' tell to @R" .. charname .. " @Dto join.@w"
	elseif BroadcastTable["DisplayType"] == 22 then
		emsg = "@DGrouping for @C(Mentor) " .. bcolour .. broadcastname .. "@D. Please send tells to @R" .. charname .. " @Dto join.@w"
	elseif BroadcastTable["DisplayType"] == 23 then
		emsg = "@DGrouping for @C(Mentor) " .. bcolour .. broadcastname .. "@D. Send '@Cinvite@D' tell to @R" .. charname .. " @Dto join.@w"
	elseif BroadcastTable["DisplayType"] == 24 then
		emsg = "@DGrouping for @C(Mentor) " .. bcolour .. broadcastname .. "@D. Send tells to @R" .. charname .. " @Dto join.@w"
	elseif BroadcastTable["DisplayType"] == 25 then
		emsg = "@C(Mentor) " .. bcolour .. broadcastname .. " @Dgroup forming." .. "@D. Send '@Cinvite@D' tell to @R" .. charname .. " @Dto join.@w"
	elseif BroadcastTable["DisplayType"] == 26 then
		emsg = "@C(Mentor) " .. bcolour .. broadcastname .. " @Dgroup forming." .. "@D. Send tells to @R" .. charname .. " @Dto join.@w"
	elseif BroadcastTable["DisplayType"] == 27 then
		emsg = "@R<<<@DGrouping for @C(Mentor) " .. bcolour .. broadcastname .. "@D, send '@Cinvite@D' tell to @R" .. charname .. "@R>>>@w"
	elseif BroadcastTable["DisplayType"] == 28 then
		emsg = "@R<<<@DGrouping for @C(Mentor) " .. bcolour .. broadcastname .. "@D. send tells to @R" .. charname .. "@R>>>@w"
	elseif BroadcastTable["DisplayType"] == 29 then
		emsg = "@R<<<@C(Mentor) " .. bcolour .. broadcastname .. " @Dgroup forming." .. "@D, send '@Cinvite@D' tell to @R" .. charname .. "@R>>>@w"
	elseif BroadcastTable["DisplayType"] == 30 then
		emsg = "@R<<<@C(Mentor) " .. bcolour .. broadcastname .. " @Dgroup forming." .. "@D, send tells to @R" .. charname .. "@R>>>@w"
	elseif BroadcastTable["DisplayType"] == 31 then
		emsg = "@R[EBroad] @DGrouping for @C(Mentor) " .. bcolour .. broadcastname .. "@D. Please send '@Cinvite@D' tell to @R" .. charname .. " @Dto join.@w"
	elseif BroadcastTable["DisplayType"] == 32 then
		emsg = "@R[EBroad] @DGrouping for @C(Mentor) " .. bcolour .. broadcastname .. "@D. Please send tells to @R" .. charname .. " @Dto join.@w"
	elseif BroadcastTable["DisplayType"] == 33 then
		emsg = "@R[EBroad] @DGrouping for @C(Mentor) " .. bcolour .. broadcastname .. "@D. Send '@Cinvite@D' tell to @R" .. charname .. " @Dto join.@w"
	elseif BroadcastTable["DisplayType"] == 34 then
		emsg = "@R[EBroad] @DGrouping for @C(Mentor) " .. bcolour .. broadcastname .. "@D. Send tells to @R" .. charname .. " @Dto join.@w"
	elseif BroadcastTable["DisplayType"] == 35 then
		emsg = "@R[EBroad] @C(Mentor) " .. bcolour .. broadcastname .. " @Dgroup forming." .. "@D. Send '@Cinvite@D' tell to @R" .. charname .. " @Dto join.@w"
	elseif BroadcastTable["DisplayType"] == 36 then
		emsg = "@R[EBroad] @C(Mentor) " .. bcolour .. broadcastname .. " @Dgroup forming." .. "@D. Send tells to @R" .. charname .. " @Dto join.@w"
	elseif BroadcastTable["DisplayType"] == 37 then
		emsg = "@R[EBroad] <<<@DGrouping for @C(Mentor) " .. bcolour .. broadcastname .. "@D, send '@Cinvite@D' tell to @R" .. charname .. "@R>>>@w"
	elseif BroadcastTable["DisplayType"] == 38 then
		emsg = "@R[EBroad] <<<@DGrouping for @C(Mentor) " .. bcolour .. broadcastname .. "@D. send tells to @R" .. charname .. "@R>>>@w"
	elseif BroadcastTable["DisplayType"] == 39 then
		emsg = "@R[EBroad] <<<@C(Mentor) " .. bcolour .. broadcastname .. " @Dgroup forming." .. "@D, send '@Cinvite@D' tell to @R" .. charname .. "@R>>>@w"
	elseif BroadcastTable["DisplayType"] == 40 then
		emsg = "@R[EBroad] <<<@C(Mentor) " .. bcolour .. broadcastname .. " @Dgroup forming." .. "@D, send tells to @R" .. charname .. "@R>>>@w"
	end
	
	return emsg
end

function CheckEpic(ename)
    for i,v in pairs(BroadcastTable["Epics"]) do
        if ename == i then return i end
    end
	
    return nil
end -- CheckEpic

function ListChannels()

	title = "Broadcasting Channels"
	
	local title2 = "+----------+----------+"
	
	spacing = TitleSpacing(title, title2)
	
	ColourNote(help_colour, "", spacing, help_command_colour, "", title)
	Note("")

	if BroadcastTable["VI"] == "NO" then
		ColourNote(msg_colour, "", title2)
		ColourNote(msg_colour, "", "| Channel  |  Status  |")
		ColourNote(msg_colour, "", title2)
	end

	for i, v in pairs(BroadcastTable["Channels"]) do
		if v == false then
			display_colour = "red" 
			displayname = "OFF"
		elseif v == true then
			display_colour = "green"
			displayname = "ON"
		end
	
		if i == nil then channelspace = "        " else channelspace = MakeSpace(i, 8) end
		
		if displayname == nil then displayspace = "   " else displayspace = MakeSpace(displayname, 3) end

		if BroadcastTable["VI"] == "NO" then		
			ColourNote(msg_colour, "", "| ", channel_colour, "", i .. channelspace, msg_colour, "", " |   ", display_colour, "", displayname .. displayspace, msg_colour, "", "    | ")
		elseif BroadcastTable["VI"] == "YES" then		
			ColourNote(msg_colour, "", "Channel: ", channel_colour, "", i .. channelspace, msg_colour, "", " Status:   ", display_colour, "", displayname .. displayspace)
		end
	end
	
	if BroadcastTable["VI"] == "NO" then
		ColourNote(msg_colour, "", title2)
	end
end -- ListChannels

-----------------------------------------------
-------------- UTILITY FUNCTIONS --------------
-----------------------------------------------
function TitleSpacing(title, title2)
	local leng = tonumber(string.len(title))
	local leng2 = tonumber(string.len(title2))
	
	local spacing = 0
	local lendif = 0
	
	if leng > leng2 then
	else
		lendif = leng2 - leng
		lendif = lendif * 0.5
	end

	spacing = string.rep(" ", lendif)
	
	return spacing
end -- TitleSpacing

function MakeSpace(title, maxleng)
	local leng = tonumber(string.len(title))
	local leng2 = tonumber(maxleng)
	
	local spacing = 0
	local lendif = 0
	
	if leng > leng2 then
	else
		lendif = leng2 - leng
	end

	spacing = string.rep(" ", lendif)
	return spacing
end -- MakeSpace

function GetCharName()
	gmcpbase = gmcp("char.base") -- fetch char.status and return it as a Lua table
	charname = string.lower(gmcpbase.name)
end -- GetCharName

---------------------------------------------
--------------- HELP FUNCTION ---------------
---------------------------------------------
function EpicBroadcasterHelp()	
	local title = "Tallimos' Epic Broadcaster v" .. PLUGIN_VERSION .. " Help"
	local title2 = noteline
	
	spacing = TitleSpacing(title, title2)
	
	ColourNote(help_colour, "", spacing, help_command_colour, "", title)
	
	if BroadcastTable["VI"] == "NO" then		
		ColourNote(help_colour, "", noteline)
		ColourNote(help_colour, "", "This plugin gives the user an easy to use broadcaster for announcing epic run groupings.")
		ColourNote(help_colour, "", noteline)
	end
	
	Note("")
	
	ColourNote(help_command_colour, "", "teb update                    ", help_colour, "", " - checks for the latest version of plugin and installs it")

	ColourNote(help_command_colour, "", "teb checkversion              ", help_colour, "", " - checks to see if there is a newer version of the plugin available")
	
	ColourNote(help_command_colour, "", "teb changelog                 ", help_colour, "", " - displays the changelog for the plugin")

	ColourNote(help_command_colour, "", "teb <enable|disable> <channel>", help_colour, "", " - enables/disables broadcasting for that particular channel")
	
	ColourNote(help_command_colour, "", "teb list                      ", help_colour, "", " - lists the channels and their broadcasting status")

	ColourNote(help_command_colour, "", "teb cancel                    ", help_colour, "", " - cancels the automatic broadcasting")
	
	ColourNote(help_command_colour, "", "teb settimer <minutes>        ", help_colour, "", " - sets the time for each automatic broacast")
	
	ColourNote(help_command_colour, "", "teb namedisplay               ", help_colour, "", " - toggles between Full and Short for epic name")
	
	ColourNote(help_command_colour, "", "teb vi                        ", help_colour, "", " - enables/disables the vi friendly option")
	
	ColourNote(help_command_colour, "", "teb setdisplay <num>          ", help_colour, "", " - sets the display type")
	ColourNote(help_colour, "", "                               - Displays 1-20 are the normal displays, Displays 21-40 are")
	ColourNote(help_colour, "", "                                 similar but displays epic with ", "cyan", "", "(Mentor)", help_colour, "", " flag")
	Note("")
	
	ColourNote(help_command_colour, "", "teb sample ", optional_colour, "", "(display number|epic name)")
	ColourNote(help_colour, "", "                               - displays an example of the broadcast message using current")
	ColourNote(help_colour, "", "                                 settings")
	ColourNote(help_colour, "", "                               - if optional ", optional_colour, "", "display number", help_colour, "", " is inputted the sample message will")
	ColourNote(help_colour, "", "                                 be of that display type")
	ColourNote(help_colour, "", "                               - if optional ", optional_colour, "", "epic name", help_colour, "", " is inputted it will show what the epic")
	ColourNote(help_colour, "", "                                 display name will appear as")
	Note("")
	
	ColourNote(help_command_colour, "", "teb setcolour <epic name> <colourcode>", help_colour, "", " - sets colour code for that particular epic")
	Note("")
	
	ColourNote(help_command_colour, "", "teb broadcast <epic name>", optional_colour, "", " (minutes til epic) (optional message)")
	ColourNote(help_colour, "", "                               - starts the broadcasting system. If the user does not input")
	ColourNote(help_colour, "", "                                 the number of minutes until the epic starts, then the grouping")
	ColourNote(help_colour, "", "                                 announcement will only broadcast once. If included the system")
	ColourNote(help_colour, "", "                                 will figure out the number of broadcasts and will start and")
	ColourNote(help_colour, "", "                                 finish broadcasting automatically including a last call.")
	Note("")
	
	ColourNote(help_colour, "", "                                 Any ", optional_colour, "", "optional message", help_colour, "", " will get added to the end of the")
	ColourNote(help_colour, "", "                                 broadcast message")
	Note("")
	
	ColourNote(help_colour, "", "Valid epic names are: ", qty_colour, "", "genie", msg_colour, "", ", ", qty_colour, "", "if1", msg_colour, "", ", ", qty_colour, "", "if2", msg_colour, "", ", ", qty_colour, "", "inferno", msg_colour, "", ", ", qty_colour, "", "oc", msg_colour, "", ", ", qty_colour, "", "winds", msg_colour, "", ", ", qty_colour, "", "titan", msg_colour, "", ", ", qty_colour, "", "terra", msg_colour, "", ", ", qty_colour, "", "oldvanir", msg_colour, "", ", ")
	ColourNote(qty_colour, "", "                      testmaze10", msg_colour, "", " and ", qty_colour, "", "trans")

	if BroadcastTable["VI"] == "NO" then		
		ColourNote(help_colour, "", noteline)
	end

	Note("")
end	-- EpicBroadcasterHelp

----------------------------------------------
--------------- SAVE FUNCTIONS ---------------
----------------------------------------------
function GetSavedData()
	if GetVariable ("ebpastfirstinstall") == "true" then
		assert (loadstring (GetVariable ("BroadcastTable") or "")) ()
		
		if BroadcastTable["Channels"]["epics"] == nil then
			BroadcastTable["Channels"]["imm"] = nil
			BroadcastTable["Channels"]["gclan"] = nil
			BroadcastTable["Channels"]["tt"] = nil
			BroadcastTable["Channels"]["gametalk"] = nil
			BroadcastTable["Channels"]["gossip"] = nil
			BroadcastTable["Channels"]["epics"] = true
		end
		
		if BroadcastTable["VI"] == nil then 
			BroadcastTable["VI"] = "NO"
		end
	else
		BroadcastTable = {}
		BroadcastTable["VI"] = "NO"
		BroadcastTable["Updating"] = "NO"
		BroadcastTable["DisplayType"] = 1
		BroadcastTable["TimerMinutes"] = 3
		BroadcastTable["DisplayNameType"] = "FullName"
		BroadcastTable["Epics"] = {}
		BroadcastTable["Epics"]["genie"] = {}
		BroadcastTable["Epics"]["genie"]["FullName"] = "Genie's Last Wish"
		BroadcastTable["Epics"]["genie"]["ShortName"] = "Genie"
		BroadcastTable["Epics"]["genie"]["Colour"] = "@M"
		BroadcastTable["Epics"]["if1"] = {}
		BroadcastTable["Epics"]["if1"]["FullName"] = "Icefall 1"
		BroadcastTable["Epics"]["if1"]["ShortName"] = "Icefall 1"
		BroadcastTable["Epics"]["if1"]["Colour"] = "@C"
		BroadcastTable["Epics"]["if2"] = {}
		BroadcastTable["Epics"]["if2"]["FullName"] = "Icefall 2"
		BroadcastTable["Epics"]["if2"]["ShortName"] = "Icefall 2"
		BroadcastTable["Epics"]["if2"]["Colour"] = "@C"
		BroadcastTable["Epics"]["inferno"] = {}
		BroadcastTable["Epics"]["inferno"]["FullName"] = "Journey to the Inferno"
		BroadcastTable["Epics"]["inferno"]["ShortName"] = "Inferno"
		BroadcastTable["Epics"]["inferno"]["Colour"] = "@r"
		BroadcastTable["Epics"]["oc"] = {}
		BroadcastTable["Epics"]["oc"]["FullName"] = "Oradrin's Chosen"
		BroadcastTable["Epics"]["oc"]["ShortName"] = "OC"
		BroadcastTable["Epics"]["oc"]["Colour"] = "@W"
		BroadcastTable["Epics"]["winds"] = {}
		BroadcastTable["Epics"]["winds"]["FullName"] = "Winds of Fate"
		BroadcastTable["Epics"]["winds"]["ShortName"] = "Winds"
		BroadcastTable["Epics"]["winds"]["Colour"] = "@Y"
		BroadcastTable["Epics"]["titan"] = {}
		BroadcastTable["Epics"]["titan"]["FullName"] = "Titans' Keep"
		BroadcastTable["Epics"]["titan"]["ShortName"] = "Titan"
		BroadcastTable["Epics"]["titan"]["Colour"] = "@R"
		BroadcastTable["Epics"]["terra"] = {}
		BroadcastTable["Epics"]["terra"]["FullName"] = "Cracks of Terra"
		BroadcastTable["Epics"]["terra"]["ShortName"] = "Terra"
		BroadcastTable["Epics"]["terra"]["Colour"] = "@y"
		BroadcastTable["Epics"]["oldvanir"] = {}
		BroadcastTable["Epics"]["oldvanir"]["FullName"] = "Oldvanir"
		BroadcastTable["Epics"]["oldvanir"]["ShortName"] = "Oldvanir"
		BroadcastTable["Epics"]["oldvanir"]["Colour"] = "@G"
		BroadcastTable["Epics"]["testmaze10"] = {}
		BroadcastTable["Epics"]["testmaze10"]["FullName"] = "Testmaze10"
		BroadcastTable["Epics"]["testmaze10"]["ShortName"] = "Testmaze10"
		BroadcastTable["Epics"]["testmaze10"]["Colour"] = "@g"
		BroadcastTable["Epics"]["trans"] = {}
		BroadcastTable["Epics"]["trans"]["FullName"] = "Transcendence"
		BroadcastTable["Epics"]["trans"]["ShortName"] = "Transcendence"
		BroadcastTable["Epics"]["trans"]["Colour"] = "@B"
		BroadcastTable["Channels"] = {}
		BroadcastTable["Channels"]["gt"] = false
		BroadcastTable["Channels"]["clan"] = false
		BroadcastTable["Channels"]["ft"] = false
		BroadcastTable["Channels"]["epics"] = true
	end

	minutes = BroadcastTable["TimerMinutes"]
	SetTimerOption ("Broadcaster", "minute", minutes)
	
	SaveState()
end -- GetSavedData

function OnPluginInstall()
	PLUGIN_VERSION  = GetPluginInfo(GetPluginID(), 19)
	PLUGIN_NAME   = GetPluginInfo(GetPluginID(), 1)

	GetSavedData()	

	if BroadcastTable["Updating"] == "YES" then
		BroadcastTable["Updating"] = "NO"
		ColourNote(msg_colour, "", "Update complete.")
	elseif BroadcastTable["Updating"] == "NO" then
		ColourNote(help_colour, "", "Thank you for installing ", qty_colour, "", "Tallimos' Epic Broadcaster v" ..  PLUGIN_VERSION, help_colour, "", ". Please see ", help_command_colour, "", "teb help", help_colour, "", " for more information.")
	end

	Note("")
end -- OnPluginInstall

function OnPluginEnable()
	GetSavedData()	
end -- OnPluginEnable

function OnPluginSaveState ()
	SetVariable ("BroadcastTable", "BroadcastTable = " .. serialize.save_simple (BroadcastTable))
	SetVariable ("ebpastfirstinstall", "true")
end -- OnPluginSaveState

-- Update code taken from Pwar's installer menu
function teb_install(name, line, wc)
   for p = 1, #pluginList do
      if pluginList[p] ~= nil and tonumber(wc.index) == p then
         printmsg("Attempting to install plugin #" .. wc.index .. " (" .. pluginList[p].name .. ")")
         install_plugin(pluginList[p])
      end
   end
   if #pluginList == 0 then
      printmsg("Error: Unable to read plugin index.")
   end
end

function teb_update(name, line, wc)
	printmsg("*** Checking if update is available for Tallimos' Epic Broadcaster.. Please wait.\r\n\r\n")
	local url = "https://raw.githubusercontent.com/tallimos/AardPlugins/main/EpicBroadcaster/Tallimos_Epic_Broadcaster.xml"
	async.doAsyncRemoteRequest(url, async_teb_download_complete, "HTTPS", 120)
end

function async_teb_download_complete(retval, page, status, headers, full_status, request_url)
  if status == 200 then
    local version = tonumber(string.match(page, '%s%s+version="([0-9%.]+)"'))
    local installedVer = GetPluginInfo(GetPluginID(), 19)
    if version > installedVer then
      printmsg("Updating from version " .. installedVer .. " to version " .. version)
      local file = io.open(GetPluginInfo(GetPluginID(), 6), "w")
      page = string.gsub(page, "\r", "")
      file:write(page)
      file:close()
      if GetAlphaOption("script_prefix") == "" then SetAlphaOption("script_prefix", "\\\\\\") end
      Execute(GetAlphaOption("script_prefix").."DoAfterSpecial(1, \"ReloadPlugin('"..GetPluginID().."')\", sendto.script)")
    else
      printmsg("You already have the latest version of Tallimos' Epic Broadcaster installed.")
    end
  else
      printmsg("Plugin update check failed...Error " .. tostring(status))
  end
end

function async_plugin_download_complete(retval, page, status, headers, full_status, request_url)
   local folder
   local xmlFiles = {}
   local xmlFile = {}
   if updatePlugin.installpath == "1" then
      folder = GetInfo(66)
   else
      folder = GetPluginInfo(GetPluginID(), 20)
   end
   --print("FOLDER IS " .. folder)
   if status == 200 then -- download successful
      printmsg("----------------------------------------------")
      printmsg("*** " .. updatePlugin.name .. " download successful.")
      f = assert(io.open (folder .. "temp_update.zip", "wb"))
      f:write(page)
      f:close()
      local zfile, err = zip.open(folder .. "temp_update.zip")
      printmsg("Extracting files from zip:")
      for file in zfile:files() do
         local currFile, err = zfile:open(file.filename)
         local currFileContents = currFile:read("*a") -- read entire contents of current file
         local hBinaryOutput = io.open(folder .. file.filename, "wb")
          -- write current file inside zip to a file outside zip
          if(hBinaryOutput)then
              hBinaryOutput:write(currFileContents)
              hBinaryOutput:close()
          end
         printmsg("(+) " .. file.filename)
         local fileExt = string.sub(file.filename, -4)
         if fileExt == ".xml" then
            xmlFile.filename = file.filename
            --print(xmlFile.filename)
            xmlFile.pluginid = string.match(currFileContents, '%s%s+id="(.-)"')            
            table.insert(xmlFiles, xmlFile)
            xmlFile = {}
         end
         currFile:close()
      end
      os.remove(folder .. "temp_update.zip")
      printmsg("Update succeeded, loading/reloading plugins.")
      printmsg("----------------------------------------------")
      for i = 1, #updatePlugin.ids do
         --if not IsPluginInstalled(thisPlugin.ids[i]) then
            --LoadPlugin(folder ..  
         --end
         --(IsPluginInstalled(thisPlugin.ids[i]) and GetPluginInfo(thisPlugin.ids[i], 17)) then
         --ReloadPlugin(updatePlugin.ids[i])
      end
      for i = 1, #xmlFiles do
         --print(xmlFiles[i].filename, xmlFiles[i].pluginid)
         --local version = tonumber(string.match(page, '%s%s+version="([0-9%.]+)"'))
         if not (IsPluginInstalled(xmlFiles[i].pluginid) and GetPluginInfo(xmlFiles[i].pluginid, 17)) then
            LoadPlugin(folder .. xmlFiles[i].filename)
         else
            ReloadPlugin(xmlFiles[i].pluginid)
         end
         installedPlugins[xmlFiles[i].pluginid] = headers["etag"]
      end
      SaveState()
   else
      printmsg("Plugin download failed...Error " .. tostring(status))
      --printmsg(headers["location"])
   end
   updatePlugin = {}
   xmlFiles = {}
end

function async_xml_download_complete(retval, page, status, headers, full_status, request_url)
   if status == 200 then
      --print(page)
      --print(status)
      lastListHash = headers["etag"]
      SaveState()
      local xml = utils.xmlread(page)
      local num_plugins = #xml.nodes [2].nodes
      --print(num_plugins)
      pluginList = {}
      for p = 1,num_plugins do
         num_plugin_nodes = #xml.nodes [2].nodes [p].nodes
         local thisPlugin = {}
         thisPlugin.ids = {}
         for n = 1, num_plugin_nodes do
            local xmlkey = xml.nodes [2].nodes [p].nodes [n].name
            local xmlval = xml.nodes [2].nodes [p].nodes [n].content
            if xmlkey == "name" then thisPlugin.name = xmlval
            elseif xmlkey == "author" then thisPlugin.author = xmlval
            elseif xmlkey == "description" then thisPlugin.description = xmlval
            elseif xmlkey == "id" then table.insert(thisPlugin.ids, xmlval)
            elseif xmlkey == "download" then thisPlugin.download = xmlval
            elseif xmlkey == "installpath" then thisPlugin.installpath = xmlval
            end
         end
         require "tprint"
         pluginList[p] = thisPlugin
         thisPlugin.installed = true
         for i = 1, #thisPlugin.ids do
            if not (IsPluginInstalled(thisPlugin.ids[i]) and GetPluginInfo(thisPlugin.ids[i], 17)) then
               thisPlugin.installed = false
               --print("Plugin not installed and enabled!!" .. thisPlugin.ids[i])
            end
         end
      end
      lastPluginList = pluginList
      SaveState()
      for p = 1, #pluginList do
         get_plugin_info(pluginList[p])
      end
   else
      printmsg("Downloading plugin list failed...Error " .. tostring(status))
   end
end

function get_plugin_info(plugin)
   local http_mode = string.sub(plugin.download, 1, 5)
   if http_mode == "https" then
      http_mode = string.upper(http_mode)
   else
      http_mode = "HTTP"
   end
   async.HEAD(plugin.download, async_head_plugin, http_mode, 120)
end

function install_plugin(plugin)
   --print("plugin.ids[1]: " .. plugin.ids[1])
   url = plugin.download
   local http_mode = string.sub(url, 1, 5)
   if http_mode == "https" then
      http_mode = string.upper(http_mode)
   else
      http_mode = "HTTP"
   end
   updatePlugin = plugin
   async.doAsyncRemoteRequest(url, async_plugin_download_complete, http_mode, 120)
end

function printmsg(msg)
   ColourNote("cornflowerblue", "", msg)
end

-- Changelog code courtesy of Durel
pluginId        = "1d1e01d90f0e2983c358b32e"

dbot = {}
----------------------------------------------------------------------------------------------------
-- dbot.version: Track the plugin's version and changelog and update the plugin 
--
-- dbot.version.changelog.get(minVersion, endTag)
-- dbot.version.changelog.getCR()
-- dbot.version.changelog.displayChanges(minVersion, changeLog)
-- dbot.version.changelog.displayChange(changeLogEntries)
--
-- dbot.version.update.release(mode, endTag)
-- dbot.version.update.releaseCR()
-- Note: dbot.version.update is derived from a plugin written by Arcidayne.  Thanks Arcidayne!
----------------------------------------------------------------------------------------------------

dbot.version               = {}

dbot.version.changelog     = {}
dbot.version.changelog.pkg = nil

dbot.version.update        = {}
dbot.version.update.pkg    = nil

drlDbotUpdateCheck         = "check"
drlDbotUpdateInstall       = "install"

drlDbotChangeLogTypeFix    = "@RFix@W"
drlDbotChangeLogTypeNew    = "@GNew@W"
drlDbotChangeLogTypeMisc   = "@yMsc@W"

function dbot.version.changelog.get(minVersion, endTag)
  local url      = "https://raw.githubusercontent.com/tallimos/AardPlugins/main/EpicBroadcaster/epicbroadcaster.changelog"
  local protocol = "HTTPS"

  if (dbot.version.changelog.pkg ~= nil) then
    Note("Skipping changelog request: another request is in progress")
  end -- if

  dbot.version.changelog.pkg            = {}
  dbot.version.changelog.pkg.url        = url
  dbot.version.changelog.pkg.protocol   = protocol
  dbot.version.changelog.pkg.minVersion = minVersion or 0
  dbot.version.changelog.pkg.endTag     = endTag
 
  dbot.version.changelog.getCR()
end -- dbot.version.changelog.get

function dbot.version.changelog.getCR()

  if (dbot.version.changelog.pkg == nil) then
    dbot.print("dbot.version.changelog.getCR: Change log package is missing!")
  end -- if

  local fileData = dbot.remote.get(dbot.version.changelog.pkg.url,
                                           dbot.version.changelog.pkg.protocol)
	if (fileData == nil) then
    dbot.print("@DNo changelog information was found. Please report to @CTallimos@D.")

  else
    loadstring(fileData)()
    if (dbot.changelog == nil) then
      dbot.print("dbot.version.changelog.getCR: Invalid changelog format detected")
    else
      dbot.version.changelog.displayChanges(dbot.version.changelog.pkg.minVersion, dbot.changelog)
    end -- if
  end -- if

  dbot.version.changelog.pkg = nil
end -- dbot.version.changelog.getCR

function dbot.version.changelog.displayChanges(minVersion, changeLog)
  local sortedLog = {}

  for k, v in pairs(changeLog) do
    table.insert(sortedLog, { version = tonumber(k) or 0, changes = v})
  end -- for
  table.sort(sortedLog, function (v1, v2) return v1.version < v2.version end)

  for _, clog in ipairs(sortedLog) do
    if (clog.version > minVersion) then
      dbot.version.changelog.displayChange(clog)
    end -- if
  end -- for

end -- dbot.version.changelog.displayChanges

-- Format of entry is: { version = 2.13,
--                       changes = { { change = drlDbotChangeLogTypeXYZ, desc = "what changed" }
--                                 }
--                     }
function dbot.version.changelog.displayChange(changeLogEntries)

  if (changeLogEntries == nil) then
    dbot.print("dbot.version.changelog.displayChange: Change entries are missing!")
    return
  end -- if

  dbot.print(string.format("@Cv%1.2f@W", changeLogEntries.version))
  for _, logEntry in ipairs(changeLogEntries.changes) do
    dbot.print(string.format("@W    (%s): %s", logEntry.change, logEntry.desc))
  end -- for
end -- dbot.version.changelog.displayChange

function dbot.version.update.release(mode, endTag)
  local url      = "https://raw.githubusercontent.com/tallimos/AardPlugins/main/EpicBroadcaster/Tallimos_Epic_Broadcaster.xml"
  local protocol = "HTTPS"
  local retval   = DRL_RET_SUCCESS

  if (mode == nil) or ((mode ~= drlDbotUpdateCheck) and (mode ~= drlDbotUpdateInstall)) then
    dbot.print("dbot.version.update.release: Missing or invalid mode parameter")
  end -- if

  if (dbot.version.update.pkg ~= nil) then
    Note("Skipping update request: another update request is in progress")
  end -- if

  dbot.version.update.pkg          = {}
  dbot.version.update.pkg.mode     = mode
  dbot.version.update.pkg.url      = url
  dbot.version.update.pkg.protocol = protocol
  dbot.version.update.pkg.endTag   = endTag

	dbot.version.update.releaseCR()	
  return retval
end -- dbot.version.update.release

function dbot.version.update.releaseCR()

  if (dbot.version.update.pkg == nil) or (dbot.version.update.pkg.mode == nil) then
    dbot.error("dbot.version.update.releaseCR: Missing or invalid update package detected")
  end -- if

  local endTag = dbot.version.update.pkg.endTag

  -- This blocks until the plugin file is returned, an error is detected, or we time out
  local pluginData, retval = dbot.remote.get(dbot.version.update.pkg.url, dbot.version.update.pkg.protocol)
  if (retval ~= DRL_RET_SUCCESS) then
    dbot.print("dbot.version.update.releaseCR: Failed to retrieve latest plugin file: " ..
              dbot.retval.getString(retval))

  elseif (pluginData == nil) then
    dbot.print("@DCould not find a remote plugin release")
    retval = DRL_RET_MISSING_ENTRY

  else
    local currentVersion = GetPluginInfo(GetPluginID(), 19) or 0
    local currentVerStr  = string.format("%1.2f", currentVersion)
    local remoteVerStr   = string.match(pluginData, '%s%s+version="([0-9%.]+)"')
    local remoteVersion  = tonumber(remoteVerStr or "") or 0

    if (remoteVersion == currentVersion) then
      dbot.print("@DYou are running the latest version of the plugin (v@C" .. currentVerStr .. "@D)")

    elseif (remoteVersion < currentVersion) then
      dbot.print("@DYour current plugin (v@C" .. currentVerStr .. "@D) " ..
                "is newer than the latest official release (v@C" .. remoteVerStr .. "@D)")
      retval = DRL_RET_VER_MISMATCH

    elseif (dbot.version.update.pkg.mode == drlDbotUpdateCheck) then
      dbot.print("@DYou are running v@C" .. currentVerStr .. "@D, latest version is v@C" .. remoteVerStr)
      dbot.print("@DChanges since your last update:")
      dbot.version.update.pkg = nil
      return dbot.version.changelog.get(currentVersion, endTag)

    elseif (dbot.version.update.pkg.mode == drlDbotUpdateInstall) then
      dbot.print("@DUpdating plugin from version @C" .. currentVerStr .. " @Dto version @C" .. remoteVerStr) 
      dbot.print("@DPlease wait until the update is complete.")

      local pluginFile = GetPluginInfo(GetPluginID(), 6)
      local file = io.open(pluginFile, "w")
      file:write(pluginData)
      file:close()
	  
	  dbot.reload()
    else
      dbot.print("@Ddbot.version.update.callback: Detected invalid mode \"@R" ..
                 (dbot.version.update.pkg.mode or "nil") .. "@W\"")
    end -- if

  end -- if

  dbot.version.update.pkg = nil

end -- dbot.version.update.releaseCR

----------------------------------------------------------------------------------------------------
-- Module to retrieve remote files
--
-- dbot.remote.get(url, protocol)
-- dbot.remote.getCR()
--
----------------------------------------------------------------------------------------------------

dbot.remote        = {}
dbot.remote.getPkg = nil

-- Blocks and then returns file, retval
-- Must be called from within a co-routine
function dbot.remote.get(url, protocol)
  local retval   = DRL_RET_SUCCESS
  local fileData = nil

  if (url == nil) or (url == "") then
    dbot.print("dbot.remote.get: missing url parameter")
    return fileData, DRL_RET_INVALID_PARAMETER
  end -- if

  if (protocol == nil) or (protocol == "") then
    dbot.print("dbot.remote.get: missing protocol parameter")
    return fileData, DRL_RET_INVALID_PARAMETER
  end -- if

  if (dbot.remote.getPkg ~= nil) then
    dbot.info("Skipping remote request: another request is in progress")
    return fileData, DRL_RET_BUSY
  end -- if

  dbot.remote.getPkg          = {}
  dbot.remote.getPkg.url      = url
  dbot.remote.getPkg.protocol = protocol
  dbot.remote.getPkg.isDone   = false

	dbot.remote.getCR()
  local timeout = 10
  local totTime = 0
  while (dbot.remote.getPkg.isDone == false) do
    if (totTime > timeout) then
      break
    end -- if
  end -- while

  if (dbot.remote.getPkg ~= nil) and (dbot.remote.getPkg.fileData ~= nil) then
    fileData = dbot.remote.getPkg.fileData
  else
    dbot.print("@DFailed to find data for file\n \"@C" .. url .. "@W\"")
  end -- if

  dbot.remote.getPkg = nil
  return fileData

end -- dbot.remote.get

function dbot.remote.getCR()
  if (dbot.remote.getPkg == nil) or (dbot.remote.getPkg.url == nil) then
    dbot.error("dbot.remote.getCR: remote package is nil or corrupted!")
    dbot.remote.getPkg = nil
    return 
  end -- if

  local urlThread = async.request(dbot.remote.getPkg.url, dbot.remote.getPkg.protocol)

  if (urlThread == nil) then
    dbot.print("dbot.remote.getCR: Failed to create thread requesting remote data")

  else
    local timeout = 10
    local totTime = 0
    while (urlThread:alive()) do
      if (totTime > timeout) then
        break
      end -- if
    end -- while

    local remoteRet, page, status, headers, fullStatus = urlThread:join()

    if (status ~= 200) then
      dbot.print("@DFailed to retrieve remote file")
    else
      dbot.remote.getPkg.fileData = page
    end -- if

    dbot.remote.getPkg.isDone = true

  end -- if
end -- dbot.remote.getCR

function dbot.print(string)
    AnsiNote(stylesToANSI(ColoursToStyles(string)))
end -- dbot.print

----------------------------------------------------------------------------------------------------
-- dbot.reload: Reloads the current plugin
--
-- Note: This code was derived from part of a plugin by Arcidayne.  Thanks Arcidayne!
----------------------------------------------------------------------------------------------------

function dbot.reload()
  local scriptPrefix = GetAlphaOption("script_prefix")
  local retval

  -- If the user has not already specified the script prefix for this version of mush, pick a
  -- reasonable default value
  if (scriptPrefix == "") then
    scriptPrefix = "\\\\\\"
    SetAlphaOption("script_prefix", scriptPrefix)
  end

  -- Tell mush to reload the plugin in one second.  We can't do it directly here because a
  -- plugin can't unload itself.  Even if it could, how could it tell mush to load it again
  -- if it weren't installed? 
  retval = Execute(scriptPrefix.."DoAfterSpecial(1, \"ReloadPlugin('"..GetPluginID().."')\", sendto.script)")
  if (retval ~= 0) then
    dbot.print("@Ddbot.reload: Failed to reload the plugin: mush error " .. retval)
  end -- if
end -- dbot.reload
]]>
</script> 

</muclient>

