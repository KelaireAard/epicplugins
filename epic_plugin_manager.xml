<?xml version="1.0" encoding="iso-8859-1"?>
<!DOCTYPE muclient>
<muclient>
<plugin
   name="Epic_Plugin_Manager"
   author="Kelaire"
   id="386f7bc25fb805370ada4e76"
   language="Lua"
   purpose="Manage and maintain multiple scripts from github"
   save_state="y"
   date_written="2025-10-10 09:00:00"
   requires="4.00"
   version="1.57"
   >
</plugin>
<!-- Alias
<alias
   script=""
   match=""
   enabled="y"
   regexp="y"
   group=""
   sequence="100"
  >
  </alias>
 -->

<aliases>
     <alias
     script="pmMain"
     match="^epm ?(.*)?$"
     enabled="y"
     regexp="y"
     sequence="100"
     >
     </alias>
     <alias match="^epm help$"
        enabled="y"
        sequence="100"
        send_to="12"
        regexp="y"
        keep_evaluating="y"
	>
	<send>
	    ShowHelp()
	</send>
	</alias>
</aliases>



<script>
<![CDATA[
require "serialize"
require "tprint"
require "aard_requirements"
require "wait"
local json = require("json")
dofile(GetInfo(60) .. "aardwolf_colors.lua")

local gitHubRaw = "https://raw.githubusercontent.com/KelaireAard/epicplugins/refs/heads/main/master/github.list"
local rawPluginUrl

function OnPluginSaveState()
	SetVariable("EPMVar", "EPMVar = " .. serialize.save_simple(EPMVar))
	SetVariable("EPMPastFirstInstall", "true")
end 

function OnPluginInstall()
   	if GetVariable ("enabled") == "false" then
		ColourNote ("yellow", "", "Warning: Plugin " .. GetPluginName() .. " is currently disabled.")
		check (EnablePlugin(GetPluginID(), false))
		return
	end 

    pluginfirstrun = "yes"
  
	OnPluginEnable()
end

function OnPluginEnable()
    EPMVar = {}
    EPMVar["cache"] = {}

    if GetVariable ("EPMPastFirstInstall") == "true" then
	  assert(loadstring(GetVariable("EPMVar") or "")) ()
    else
      EPMVar["Debug"] = "no"
	end
	
    ColourNote("Red","","Installing "..GetPluginName().." version "..GetPluginInfo (GetPluginID (), 19).."...")
	
	ColourNote("Red","","EPM help will display the helpfile")
     
    makeRawUrl()
    buildCache()
end


function string.explode(str , seperator , plain)
  assert(type(seperator) == "string" and seperator ~= "" , "Invalid seperator (need string of length >= 1)")
 
  local t , nexti = { } , 1
  local pos = 1
  while true do
  local st , sp = str:find ( seperator , pos , plain )
  if not st then break end -- No more seperators found
    if pos ~= st then
      t [ nexti ] = str:sub ( pos , st - 1 ) -- Attach chars left of current divider
      nexti = nexti + 1
    end
  
    pos = sp + 1 -- Jump past current divider
  end
  
  t [ nexti ] = str:sub ( pos ) -- Attach chars right of last divider
  return t
end

function getName(Data, pretty)
  local name = Data:match('%s+[Nn][Aa][Mm][Ee]="[Hh][Aa][Dd][Aa][Rr][Ss]?_([%w_]+)"')
  if not name then
    -- fallback: accept any name="..." and take the part after the last underscore if present
    local any = Data:match('%s+[Nn][Aa][Mm][Ee]="([^"]+)"')
    if any then
      name = any:match('([^_]+)$') or any  -- take last segment or whole
    end
  end
  if not name then return nil end
  if pretty then
    name = name:gsub('_',' '):upper()
  end
  return name
end  function center_text(str, width)  local pad = (width - #str) / 2  if pad < 0 then pad = 0 end  return string.rep(" ", math.floor(pad)) .. str .. string.rep(" ", math.ceil(pad))end


function pmMain(n,l,wc)

     local first, rest = wc[1]:match("(%w+)%s*(.*)")
     
     if first == nil then
          ShowHelp()
          return
     end
     
     if first == "check" then
          EPMVar["Initialized"]="no"
          EPMCheck()
     elseif first == "selfupdate" then
          EPMSelfUpdate()
     elseif first == "install" then
          EPMInstall(rest)
     elseif first == "update" then
          EPMUpdate(rest)
     elseif first == "remove" then
          EPMremove(rest)
     elseif first == "reload" then
          EPMReload(rest)
     elseif first == "help" then
          ShowHelp(rest)
     elseif first == "show" then
          tprint(EPMVar["cache"])
     elseif first == "delcache" then
          EPMVar["cache"] = {}
     elseif first == "debug" then
          if EPMVar["Debug"] == "no" then
               EPMVar["Debug"] = "yes"
               ColourNote("Red","","EPM: Debugging turned on")
          else
               ColourNote("Red","","EPM: Debugging turning off")
               EPMVar["Debug"] = "no"
          end
     end
     
end

function EPMCheck()
  local function ci_get(tbl, key)  -- case-insensitive field getter
    local lk = key:lower()
    for k, v in pairs(tbl or {}) do
      if type(k) == "string" and k:lower() == lk then return v end
    end
  end
 
  if EPMVar["Initialized"] == "yes" then
    local groups = {}

    for num, data in ipairs(EPMVar["cache"]) do
	  if EPMVar["Debug"] == "yes" then
        local cat_dbg = data.Category or data.category or "(nil)"
        ColourNote("Orange","", "EPM: cache["..num.."].Category = "..tostring(cat_dbg))
      end
      -- display label
      local short = ci_get(data, "ShortName") or ci_get(data, "WName") or data.ShortName or data.WName or ""

      -- *** READ CATEGORY DIRECTLY (case-insensitive), else Default
      local cat = ci_get(data, "Category") or data.Category or data.category or ""
      cat = tostring(cat):gsub("^%s+",""):gsub("%s+$","")
      if cat == "" then cat = "Default" end

      -- (optional) debug of what we actually *read* here
      if EPMVar["Debug"] == "yes" then
        ColourNote("Yellow","", "EPM: list-read category for #"..num.." = ["..cat.."]")
      end

      local entry = {
        num = num,
        data = data,
        script_short = string.upper((short:gsub("_", " "))),
      }
      groups[cat] = groups[cat] or {}
      table.insert(groups[cat], entry)
    end

    -- sort categories then print (unchanged) ...
	local order = { OC=1, Winds=2, IceFall=3, Inferno=4, Genie=5, Trans=6, Titan=7, Terra=8, SKD=9, Utility=98, Default=99 }
	local colors = { OC="White", Winds="Yellow", IceFall="Cyan", Inferno="DarkRed", Genie="Magenta", Trans="Blue", Terra="DarkYellow", Titan="Red" } 

	local catnames = {}
	for cat,_ in pairs(groups) do table.insert(catnames, cat) end
    table.sort(catnames, function(a,b)
      local ra = order[a] or 50
      local rb = order[b] or 50
      if ra ~= rb then return ra < rb end
      return a:lower() < b:lower()
    end)
    
    --table.sort(catnames, function(a,b) return a:lower() < b:lower() end)

    ColourNote("White", "slateblue",
	"        [List of maintained plugins]        ")
	--                                                      123456789012345678901234567890123456789012
	ColourNote("White", "slateblue", " ", "cyan", "", "To see information about a plugin, click  ","White", "slateblue", " ")
	ColourNote("White", "slateblue", " ", "cyan", "", " on the plugin name.                      ","White", "slateblue", " ")    local firstRun = 0

    for _, cat in ipairs(catnames) do
      table.sort(groups[cat], function(a,b)
        return a.script_short:lower() < b.script_short:lower()
      end)	
      ColourNote("White", "slateblue","  ","White", "slateblue", center_text(string.format("==[ %s ]==", cat), 40),"White", "slateblue","  ")

      for _, e in ipairs(groups[cat]) do
        local num  = e.num
        local script_short = e.script_short		

        if IsPluginInstalled(EPMVar["cache"][num]["PluginId"]) then
          local gh  = tonumber(EPMVar["cache"][num]["GHVersion"])
          local loc = tonumber(EPMVar["cache"][num]["LocalVersion"])		  		  if loc >= gh then            ColourTell("White", "slateblue"," ","Cyan", "", " [", "Green", "", "x", "Cyan", "", "] ")          else            ColourTell("White", "slateblue"," ","Cyan", "", " [", "Yellow", "", "x", "Cyan", "", "] ")          end                    Hyperlink("epm help "..num, string.format("%-20s", script_short),	             	"Plugin Information", "SkyBlue", "black", 0, 1)		
          if not gh or not loc then
            ColourNote("Red","","EPM: Version number not cached, please run command again")
            if EPMVar["Debug"] == "yes" then tprint(EPMVar["cache"]) end
            return
          end
          if loc < gh then
            Hyperlink("epm update "..num, "[Update]", "Download and Update Plugin", "DarkOrange", "black", 0, 1)
          else
            Hyperlink("epm reload "..num, "[Reload]", "Reload plugin", "Teal", "black", 0, 1)
          end
          Hyperlink("epm remove "..num, "[Remove]", "Remove plugin", "Red", "black", 0, 1)		  ColourTell("White",""," ")
          ColourTell("White", "slateblue"," ")		  print("")
        else		  ColourTell("White", "slateblue"," ","Cyan", "", " [ ] ")		  Hyperlink("epm help "..num, string.format("%-20s", script_short),	             	"Plugin Information", "SkyBlue", "black", 0, 1)
          Hyperlink("epm install "..num, "[Install]", "Install Plugin", "DarkOrange", "black", 0, 1)		  ColourTell("White","","        ")
          ColourTell("White", "slateblue"," ")		  print("")
        end
	  end
    end

    ColourNote("White", "slateblue",
      "                                            ")
  else
    makeRawUrl()
    buildCache()
  end
end





function EPMUpdate(PID)
     local num, args = PID:match("(%d+)%s*(.*)")

     if num ~= nil then
          num = tonumber(num)
     else
          ColourNote("Red","","EPM: You need to supply a number, EG EPM update 1")
          return;
     end

     if args ~= "" then
          --do stuff with args here (maybe)
     end

     local script_id = num
     local script_name = EPMVar["cache"][script_id]["LongName"]
     local script_url = EPMVar["cache"][script_id]["url"]
     local script_pid = EPMVar["cache"][script_id]["PluginId"]
     local script_short = string.upper(string.gsub(EPMVar["cache"][script_id]["ShortName"],"_"," "))
     local script_rawurl

     if tonumber(EPMVar["cache"][script_id]["LocalVersion"]) == nil or tonumber(EPMVar["cache"][script_id]["GHVersion"]) == nil then
          ColourNote("Red","","EPM: Something went wrong while caching, please run EPM check again")
          if EPMVar["Debug"] == "yes" then
               ColourNote("Red","","EPM: If in Debug, you will see a table, copy and paste to Kelaire via personal note or mb.aardwolfboot.com: with this message epm update == nil"..script_id)
               tprint(EPMVar["cache"])
          end
          return
     end

     if tonumber(EPMVar["cache"][script_id]["LocalVersion"]) >= tonumber(EPMVar["cache"][script_id]["GHVersion"]) then
          ColourNote("Red","","EPM: Plugin: "..script_short.." Already up to date, if need to reload use EPM reload "..num)
          return
     end
     
     ColourNote("Red","","EPM: Updating Plugin "..script_short)
    
     UnloadPlugin(script_pid)
     
     async_ok, async = pcall (require, "async")
     if async_ok then
          script_rawurl = async.request(script_url, "HTTPS")
          retval, page, status, headers, full_status = script_rawurl:join()
          
          if status == 200 then
               local lscript = io.open(script_name,"w")
               lscript:write(page)
               lscript:close()
          end --end status 200
     end --end async_ok
     ColourNote("Red","","EPM: Plugin "..script_short.." Updated Enjoy!")
     LoadPlugin(script_name)
end

function EPMInstall(PID)
     local num, args = PID:match("(%d+)%s*(.*)")

     if num ~= nil then
          num = tonumber(num)
     else
          ColourNote("Red","","EPM: You need to supply a number, EG EPM install 1")
          return;
     end

     if args ~= "" then
          --do stuff with args here (maybe)
     end

     local script_id = num
     local script_directory = GetInfo(60)
     local script_name = EPMVar["cache"][script_id]["LongName"]
     local script_url = EPMVar["cache"][script_id]["url"]
     local script_pid = EPMVar["cache"][script_id]["PluginId"]
     local script_short = string.upper(string.gsub(EPMVar["cache"][script_id]["ShortName"],"_"," "))
     local script_install = script_directory .. EPMVar["cache"][script_id]["RawName"]..".xml"
     local script_rawurl

     if IsPluginInstalled(script_pid) then
          ColourNote("Red","","EPM: Plugin: "..script_short.." Already installed, if you need to reload it use, EPM reload "..num)
          return
     end

    ColourNote("Red","","EPM: Installing Plugin "..script_short)
      
     async_ok, async = pcall (require, "async")
     if async_ok then
          script_rawurl = async.request(script_url, "HTTPS")
          retval, page, status, headers, full_status = script_rawurl:join()
          
          if status == 200 then
               print("Plugin installing")
               local lscript = io.open(script_install,"w")
               lscript:write(page)
               lscript:close()
          else --end status 200
               ColourNote("Red","","EPM: status was not 200")
          end
     end --end async_ok
     ColourNote("Red","","EPM: Plugin "..script_short.." Installed Enjoy!")
     LoadPlugin(script_name)

end

function EPMReload(PID)
     local num, args = PID:match("(%d+)%s*(.*)")

     if num ~= nil then
          num = tonumber(num)
     else
          ColourNote("Red","","EPM: You need to supply a number, EG EPM reload 1")
          return;
     end

     if args ~= "" then
          --do stuff with args here (maybe)
     end

     local script_id = num
     local script_name = EPMVar["cache"][script_id]["LongName"]
     local script_url = EPMVar["cache"][script_id]["url"]
     local script_pid = EPMVar["cache"][script_id]["PluginId"]
     local script_short = string.gsub(EPMVar["cache"][script_id]["ShortName"],"_"," ")

     if IsPluginInstalled(script_pid) then
          ColourNote("Red","","EPM: Currently reloading script: "..script_short.." please stand by")
          ReloadPlugin(script_pid)
     else
          ColourNote("Red","","EPM: Plugin: "..script_short.." Not installed, please use EPM install "..num)
     end
end

function EPMremove(PID)
     local num, args = PID:match("(%d+)%s*(.*)")

     if num ~= nil then
          num = tonumber(num)
     else
          ColourNote("Red","","EPM: You need to supply a number, EG EPM remove 1")
          return;
     end

     if args ~= "" then
          --do stuff with args here (maybe)
     end

     local script_id = num
     local script_name = EPMVar["cache"][script_id]["LongName"]
     local script_url = EPMVar["cache"][script_id]["url"]
     local script_pid = EPMVar["cache"][script_id]["PluginId"]
     local script_short = string.gsub(EPMVar["cache"][script_id]["ShortName"],"_"," ")

     if IsPluginInstalled(script_pid) then
          ColourNote("Red","","EPM: Currently removing script: "..script_short.." please stand by")
          UnloadPlugin(script_pid)
          local ok, err = os.remove(script_name)
          if ok then
               ColourNote("Red","","EPM: Removed script:"..script_short)
          else
               ColourNote("Red","","EPM: Was not able to remove"..script_short.." "..err)
          end
     else
          ColourNote("Red","","EPM: Plugin: "..script_short.." Not installed, please use EPM install "..num)
     end
end

function makeRawUrl()
     async_ok, async = pcall (require, "async")
     if async_ok then
     
     makeRawURL = async.request(gitHubRaw, "HTTPS")
     retval, page, status, headers, full_status = makeRawURL:join()
     
     if status == 200 then
          rawPluginUrl = string.explode(page,"\n")
     end--end 200
     end --end async_ok
     return rawPluginUrl
end

function tablelength(T)
  local count = 0
  for i,v in pairs(T) do 
     if v ~= "" then
          count = count + 1
     end
  end
  return count
end

function buildCache()
     cache_Len = tablelength(rawPluginUrl)
	 if EPMVar["Debug"] == "yes" then
       ColourNote("Red","","EPM: BuildCache().cache_Len: ("..cache_Len..")")
	 end
     cache_res = 0
	 if EPMVar["Debug"] == "yes" then
       ColourNote("Red","","EPM: BuildCache().cache_res: ("..cache_res..")")
	 end
     EPMVar["cache"] = {}
     EPMVar["Initialized"]="no"
     
     async_ok, async = pcall (require, "async")
     if async_ok then
          
          for a,b in pairs (rawPluginUrl) do
               if b == nil or b == "" or b==" " then
                    return
               else
                    plugin_page = async.doAsyncRemoteRequest(b, raw_get_cache, "HTTPS") 
               end
          end -- end for loop
			
	else
		ColourNote("Red","","EPM: something went wrong with async in building cache")
	end --end if async_ok
     
end --end function buildCache()

function raw_get_cache(retval, page, status, headers, full_status, request_url)
     local WName,rawname,ghVersion,pid,lVersion,lname,_,description,category


     cache_res = cache_res + 1
	 if EPMVar["Debug"] == "yes" then
       ColourNote("Red","","EPM: raw_get_cache().cache_res: ("..cache_res..")")
	   ColourNote("Red","","EPM: ----------------")
	 end
	 if EPMVar["Debug"] == "yes" then
       if status~= nil then ColourNote("Red","","EPM: Status:"..status) else ColourNote("Red","","EPM: Status:NIL") end
	 end
     
     if status == 200 then
	  -- WName: from page, else from URL, else "UNKNOWN"
	  WName = getName(page, false)
	  if not WName and request_url then
		local from_url = request_url:match('/([^/]+)$')
		if from_url then
		  WName = from_url:gsub('%.xml$',''):gsub('%.txt$','')
		end
	  end
	  WName = WName or "UNKNOWN"
	  if EPMVar["Debug"] == "yes" then
	    ColourNote("Red","","EPM: set wname:"..tostring(WName))
	  end

	  -- rawname: from page, else fall back to WName
	  --rawname = page:match('%s+[Nn][Aa][Mm][Ee]="([%w_]+)"') or WName
	  --if EPMVar["Debug"] == "yes" then
	  --  ColourNote("Red","","EPM: set rawname:"..tostring(rawname))
	  --end
	  
      -- grab Name="..." (case-insensitive), fallback to WName
	  local nameval = page:match('%s+[Nn][Aa][Mm][Ee]%s*=%s*"%s*([^"]-)%s*"') or WName

	  -- split at the first underscore
	  local cat, rn = nameval:match('^([^_]+)_(.+)$')
	  category, rawname = cat and cat or "Default", rn and rn or nameval

	  if EPMVar["Debug"] == "yes" then 
	    ColourNote("Red","","EPM: set category:"..tostring(category))
	    ColourNote("Red","","EPM: set rawname:"..tostring(rawname))
	  end

	  -- version: accept any digits & dots; default "0"
	  ghVersion = page:match('[\r\n]%s*[Vv][Ee][Rr][Ss][Ii][Oo][Nn]="(%d+%.%d+)"%s*[\r\n]') or "0"
	  if EPMVar["Debug"] == "yes" then
	    ColourNote("Red","","EPM: set github version:"..tostring(ghVersion))
	  end
	  
	  -- get description (purpose="...")
	  -- use two-capture pattern but bind the 2nd capture
	  _, description = page:match('[Pp][Uu][Rr][Pp][Oo][Ss][Ee]%s*=%s*([\'"])(.-)%1')
	  -- fallback: try explicit single-capture patterns (just in case)
	  if not description or description == "" then
		description = page:match('[Pp][Uu][Rr][Pp][Oo][Ss][Ee]%s*=%s*"(.-)"')
			 or page:match("[Pp][Uu][Rr][Pp][Oo][Ss][Ee]%s*=%s*'(.-)'")
			 or ""
	  end
	  if EPMVar["Debug"] == "yes" then
	    ColourNote("Red","","EPM: set description:"..tostring(description))
      end

	  -- plugin id: allow hyphens too; default empty
	  pid = page:match('%s+[Ii][Dd]="([%w%-]+)"') or ""
	  if EPMVar["Debug"] == "yes" then
	    ColourNote("Red","","EPM: set plugin id:"..tostring(pid))
	  end

	  -- local version: only query if we have a pid
	  lVersion = (pid ~= "" and GetPluginInfo(pid,19)) or 0
	  if EPMVar["Debug"] == "yes" then
	    ColourNote("Red","","EPM: set local version:"..tostring(lVersion))
	  end

	  -- long name: safe fallback even if rawname is nil
	  local longNameFallback = (GetInfo and GetInfo(60) or "") .. (rawname or "plugin") .. ".xml"
	  lname = (pid ~= "" and GetPluginInfo(pid,6)) or longNameFallback
	  if EPMVar["Debug"] == "yes" then
	    ColourNote("Red","","EPM: set long name:"..tostring(lname))
	  end

	  -- ensure the cache bucket exists before we write
	  EPMVar["cache"][cache_res] = EPMVar["cache"][cache_res] or {}

     else
          ColourNote("Red","","EPM: Cant connect to github")
          cache_res = cache_res + 1
          return
     end
     
   
     if cache_res >= cache_Len then 
		  if EPMVar["Debug"] == "yes" then
            ColourNote("Red","","EPM: Fired(1) Cache_Res("..cache_res..") >= cache_Len("..cache_Len..")")   
		  end
          EPMVar["cache"][cache_res]["ShortName"] = WName
          EPMVar["cache"][cache_res]["RawName"] = rawname
          EPMVar["cache"][cache_res]["GHVersion"] = ghVersion
          EPMVar["cache"][cache_res]["PluginId"] = pid
		  EPMVar["cache"][cache_res]["Description"] = description
		  EPMVar["cache"][cache_res]["Category"] = category
          EPMVar["cache"][cache_res]["LocalVersion"] = lVersion
          EPMVar["cache"][cache_res]["LongName"] = lname
          EPMVar["cache"][cache_res]["url"] = request_url
          EPMVar["Initialized"]="yes"
          if pluginfirstrun == "yes" then
               pluginfirstrun = "no"
          else
               EPMCheck()
          end
     else
	      if EPMVar["Debug"] == "yes" then
            ColourNote("Red","","EPM: Fired(2) Cache_Res("..cache_res..") < cache_Len("..cache_Len..")")   
		  end
          EPMVar["cache"][cache_res]["ShortName"] = WName
          EPMVar["cache"][cache_res]["RawName"] = rawname
          EPMVar["cache"][cache_res]["GHVersion"] = ghVersion
          EPMVar["cache"][cache_res]["PluginId"] = pid
		  EPMVar["cache"][cache_res]["Description"] = description
		  EPMVar["cache"][cache_res]["Category"] = category
          EPMVar["cache"][cache_res]["LocalVersion"] = lVersion
          EPMVar["cache"][cache_res]["LongName"] = lname
          EPMVar["cache"][cache_res]["url"] = request_url
     
     end -- end counting if
	 if EPMVar["Debug"] == "yes" then
       ColourNote("Red","","EPM: ----------------")
	 end
     
     
end--end raw_get


--[[
Self updating code below taken from crowley because im too lazy to write my own
check him out on github
https://github.com/AardCrowley/Aardwolf-Scripts
]]

function EPMSelfUpdate()
     raw = "https://raw.githubusercontent.com/KelaireAard/epicplugins/refs/heads/main/epic_plugin_manager.xml"
     async_ok, async = pcall (require, "async")
     PLUGIN_VERSION  = GetPluginInfo(GetPluginID(), 19)
     PLUGIN_NAME   = GetPluginInfo(GetPluginID(), 1)
     if async_ok then
          plugin_page = async.doAsyncRemoteRequest(raw, Raw_Update, "HTTPS")
     else
          ColourNote("Red","","EPM: Error on updating")
     end
end

function Raw_Update(retval, page, status, headers, full_status, request_url)
        if status == 200 then
            raw_version = tonumber(string.match(page, '%s%s+version="(%d+%.?%d+)"'))
        end

        if tonumber(raw_version) == tonumber(PLUGIN_VERSION) then
            ColourNote("Red","","EPM: "..PLUGIN_NAME .. " is up to date!")
        elseif tonumber(raw_version) > tonumber(PLUGIN_VERSION) then
            ColourNote("Red","","EPM: Updating from version "..PLUGIN_VERSION.." to "..raw_version.." Please stand by.")
            local file = io.open(GetPluginInfo(GetPluginID(), 6), "w")
            file:write(page)
            file:close()
            if "" == GetAlphaOption("script_prefix") then
                SetAlphaOption("script_prefix", "\\\\\\")
            end
            Execute(GetAlphaOption("script_prefix") .. "DoAfterSpecial(1, \"ReloadPlugin('" .. GetPluginID() .. "')\", sendto.script)")
            EPMVar["cache"] = {}
            ColourNote("Red","","EPM: Updating is complete, Have a muddish day!")
        elseif tonumber(raw_version) < tonumber(PLUGIN_VERSION) then
          ColourNote("Red","","EPM: Your development is too quick!")
        end
        raw_version = nil
    end -- end Update code

--end of self update code

function ShowHelp(PID)
  local num, args = (PID or ""):match("(%d+)%s*(.*)")
  if not num then
    ColourNote("Red","","EPM: +-----------------------[Plugin Manager V:"..GetPluginInfo(GetPluginID(), 19).."]------------------------+")
    ColourNote("Red","","EPM: | epm help                - Displays this helpfile                     |")
    ColourNote("Red","","EPM: | epm check               - Checks to see if there is any updates      |")
    ColourNote("Red","","EPM: | epm selfupdate          - Checks for updates on this script          |")
    ColourNote("Red","","EPM: | epm help <number>       - Displays help for plugin                   |")
    ColourNote("Red","","EPM: | epm update <number>     - updates plugin with number from epm check  |")
    ColourNote("Red","","EPM: | epm reload <number>     - reloads plugin with number from epm check  |")
    ColourNote("Red","","EPM: | epm install <number>    - installs plugin with number from epm check |")
    ColourNote("Red","","EPM: | epm remove <number>     - removes plugin with number from epm check  |")
    ColourNote("Red","","EPM: +----------------------------------------------------------------------+")
    return
  end
  num = tonumber(num)
  local entry = EPMVar["cache"][num]
  if not entry then
    ColourNote("Red","","EPM: No cached entry for #" .. tostring(num) .. ". Try 'epm check' first.")
    return
  end
  local script_name        = entry["LongName"]      or "(unknown)"
  local short_name         = entry["ShortName"]     or "(unknown)"
  local script_description = entry["Description"]   or "(no description)"
  ColourNote("Red","","EPM: " .. short_name .. " - " .. script_description)
end
]]>
</script> 


</muclient>